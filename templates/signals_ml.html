{% extends "base_layout.html" %}

{% block title %}Signals & ML - Grim Trader v2.0{% endblock %}
{% block page_title %}Signals & ML Analysis{% endblock %}
{% block page_subtitle %}Hybrid scoring system combining ML predictions with technical analysis{% endblock %}

{% block body_class %}data-signals-page{% endblock %}

{% block extra_css %}
<style>
.signal-analysis-card {
    background: var(--primary-dark);
    border: 2px solid var(--border-color);
    border-radius: 15px;
    padding: 25px;
    margin-bottom: 25px;
    position: relative;
}

.signal-score {
    font-size: 3rem;
    font-weight: 800;
    text-align: center;
    margin: 20px 0;
    background: linear-gradient(135deg, #3b82f6, #06b6d4);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.score-breakdown {
    background: var(--secondary-dark);
    border-radius: 10px;
    padding: 20px;
    margin: 15px 0;
    border: 1px solid var(--border-color);
}

.confidence-meter {
    height: 30px;
    background: var(--secondary-dark);
    border-radius: 15px;
    overflow: hidden;
    position: relative;
    margin: 10px 0;
    border: 1px solid var(--border-color);
}

.confidence-fill {
    height: 100%;
    transition: width 0.8s ease;
    border-radius: 15px;
    position: relative;
}

.confidence-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.2) 50%, transparent 100%);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.signal-badge {
    font-size: 1.2rem;
    padding: 10px 20px;
    border-radius: 25px;
    font-weight: 600;
    text-transform: uppercase;
    border: 2px solid;
    position: relative;
    overflow: hidden;
}

.signal-badge.bg-success {
    background: var(--success-green);
    border-color: var(--success-green);
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
}

.signal-badge.bg-warning {
    background: var(--warning-orange);
    border-color: var(--warning-orange);
    box-shadow: 0 0 20px rgba(251, 146, 60, 0.3);
}

.signal-badge.bg-danger {
    background: var(--danger-red);
    border-color: var(--danger-red);
    box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
}

.signal-badge.bg-secondary {
    background: var(--secondary);
    border-color: var(--secondary);
}

.indicator-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin: 20px 0;
}

.indicator-item {
    background: var(--secondary-dark);
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    border: 1px solid var(--border-color);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    position: relative;
    overflow: hidden;
}

.indicator-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}

.indicator-item .value {
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 5px;
}

.indicator-item .label {
    font-size: 0.9rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.ml-prediction-box {
    background: linear-gradient(135deg, var(--accent-blue), var(--secondary-dark));
    border-radius: 15px;
    padding: 25px;
    margin: 20px 0;
    border: 2px solid var(--success-green);
    position: relative;
    overflow: hidden;
}

.ml-prediction-box::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(6, 182, 212, 0.1));
    pointer-events: none;
}

.status-indicator {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 0.9rem;
    font-weight: 500;
    margin-left: 15px;
}

.status-live {
    background: rgba(34, 197, 94, 0.2);
    border: 1px solid var(--success-green);
    color: var(--success-green);
}

.status-loading {
    background: rgba(59, 130, 246, 0.2);
    border: 1px solid var(--accent-blue);
    color: var(--accent-blue);
}

.loading-skeleton {
    background: linear-gradient(90deg, var(--secondary-dark) 0%, var(--border-color) 50%, var(--secondary-dark) 100%);
    background-size: 200% 100%;
    animation: loading-wave 1.5s infinite;
    border-radius: 4px;
    height: 1.5rem;
    margin: 5px 0;
}

@keyframes loading-wave {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}

.last-updated {
    position: absolute;
    top: 15px;
    right: 15px;
    font-size: 0.8rem;
    color: var(--text-muted);
    background: var(--secondary-dark);
    padding: 5px 10px;
    border-radius: 15px;
    border: 1px solid var(--border-color);
}

.enhanced-filters-box {
    background: var(--secondary-dark);
    border-radius: 10px;
    padding: 20px;
    margin: 15px 0;
    border: 1px solid var(--border-color);
}

.signal-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 8px 0;
    padding: 5px 0;
    border-bottom: 1px solid var(--border-color);
}

.signal-row:last-child {
    border-bottom: none;
}

.check-icon {
    color: var(--success-green);
}

.x-icon {
    color: var(--danger-red);
}
</style>
{% endblock %}

{% block content %}
<!-- Symbol Selection -->
<div class="data-card mb-4">
    <div class="row align-items-center">
        <div class="col-md-6">
            <label for="symbolSelect" class="form-label">
                <i class="fas fa-chart-line me-2"></i>Select Asset for Analysis
            </label>
            <select class="form-select form-select-lg" id="symbolSelect" onchange="loadSignalAnalysis()">
                <option value="BTC">Bitcoin (BTC)</option>
                <option value="ETH">Ethereum (ETH)</option>
                <option value="SOL">Solana (SOL)</option>
                <option value="ALGO">Algorand (ALGO)</option>
                <option value="ATOM">Cosmos (ATOM)</option>
                <option value="LINK">Chainlink (LINK)</option>
                <option value="UNI">Uniswap (UNI)</option>
                <option value="COMP">Compound (COMP)</option>
            </select>
        </div>
        <div class="col-md-6 text-end">
            <button class="btn btn-outline-primary btn-lg" onclick="refreshSignalData()" id="refreshBtn">
                <i class="fas fa-sync-alt me-2"></i>Refresh Analysis
            </button>
            <div class="status-indicator status-loading" id="statusIndicator">
                <i class="fas fa-spinner fa-spin"></i>
                <span>Loading...</span>
            </div>
        </div>
    </div>
</div>

<!-- Hybrid Signal Score -->
<div class="signal-analysis-card">
    <div class="last-updated" id="lastUpdated" data-timestamp>Loading...</div>
    <div class="row">
        <div class="col-lg-4 text-center">
            <h5><i class="fas fa-crosshairs me-2"></i>Hybrid Signal Score</h5>
            <div class="signal-score" id="hybridScore" data-metric="hybridScore" data-value>
                <div class="loading-skeleton" style="width: 80px; height: 60px; margin: 0 auto;"></div>
            </div>
            <div class="signal-badge bg-secondary" id="signalBadge" data-signal>
                <div class="loading-skeleton" style="width: 80px; height: 20px; margin: 0 auto;"></div>
            </div>
        </div>
        <div class="col-lg-8">
            <h6><i class="fas fa-analytics me-2"></i>Score Breakdown</h6>
            <div class="score-breakdown">
                <div class="row">
                    <div class="col-6">
                        <h6 class="text-info"><i class="fas fa-chart-area me-2"></i>Traditional Analysis (60%)</h6>
                        <div class="confidence-meter">
                            <div class="confidence-fill bg-info" id="traditionalFill" style="width: 0%"></div>
                        </div>
                        <div id="traditionalScore" data-metric="traditionalScore" data-value>
                            <div class="loading-skeleton" style="width: 60px;"></div>
                        </div>
                    </div>
                    <div class="col-6">
                        <h6 class="text-warning"><i class="fas fa-brain me-2"></i>ML Prediction (40%)</h6>
                        <div class="confidence-meter">
                            <div class="confidence-fill bg-warning" id="mlFill" style="width: 0%"></div>
                        </div>
                        <div id="mlScore" data-metric="mlScore" data-value>
                            <div class="loading-skeleton" style="width: 60px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Technical Indicators & ML Prediction -->
<div class="row">
    <div class="col-lg-8">
        <div class="data-card">
            <h5 class="card-title">
                <i class="fas fa-chart-line me-2"></i>Technical Indicators
            </h5>
            <div class="indicator-grid" id="indicatorGrid">
                <div class="indicator-item">
                    <div class="value" id="rsiValue" data-indicator="rsi" data-value>
                        <div class="loading-skeleton"></div>
                    </div>
                    <div class="label">RSI (14)</div>
                </div>
                <div class="indicator-item">
                    <div class="value" id="volatilityValue" data-indicator="volatility" data-value>
                        <div class="loading-skeleton"></div>
                    </div>
                    <div class="label">Volatility</div>
                </div>
                <div class="indicator-item">
                    <div class="value" id="volumeValue">
                        <div class="loading-skeleton"></div>
                    </div>
                    <div class="label">Volume Ratio</div>
                </div>
                <div class="indicator-item">
                    <div class="value" id="momentumValue">
                        <div class="loading-skeleton"></div>
                    </div>
                    <div class="label">Momentum</div>
                </div>
                <div class="indicator-item">
                    <div class="value" id="supportValue">
                        <div class="loading-skeleton"></div>
                    </div>
                    <div class="label">Support Level</div>
                </div>
                <div class="indicator-item">
                    <div class="value" id="bollingerValue">
                        <div class="loading-skeleton"></div>
                    </div>
                    <div class="label">Bollinger Bands</div>
                </div>
            </div>
            
            <!-- Enhanced Filters Detail -->
            <div class="enhanced-filters-box" id="enhancedFiltersBox" style="display: none;">
                <h6><i class="fas fa-filter me-2"></i>Signal Components</h6>
                <div id="enhancedFiltersContent">
                    <!-- Will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>
    <div class="col-lg-4">
        <div class="ml-prediction-box">
            <h5 class="text-center text-white">
                <i class="fas fa-robot me-2"></i>ML Prediction Engine
            </h5>
            <div class="text-center">
                <div class="h2 text-success" id="mlProbability">
                    <div class="loading-skeleton" style="width: 80px; height: 40px; margin: 0 auto;"></div>
                </div>
                <div class="text-light mb-3">Success Probability</div>
                <div class="mt-3">
                    <small class="text-light" id="mlDetails">
                        <div class="loading-skeleton" style="height: 60px;"></div>
                    </small>
                </div>
            </div>
        </div>
        
        <!-- System Info -->
        <div class="data-card">
            <h6><i class="fas fa-info-circle me-2"></i>System Info</h6>
            <div id="systemInfo">
                <div class="loading-skeleton" style="height: 80px;"></div>
            </div>
        </div>
    </div>
</div>

<!-- Signal History Table -->
<div class="data-card">
    <h5 class="card-title">
        <i class="fas fa-history me-2"></i>Recent Signal History
        <button class="btn btn-sm btn-outline-primary ms-3" onclick="exportSignalHistory()">
            <i class="fas fa-download me-1"></i>Export CSV
        </button>
        <span class="badge bg-info ms-2" id="historyCount">Loading...</span>
    </h5>
    
    <div class="table-responsive">
        <table class="table-v02" style="--v02-head-bg: #6c7ae0;">
            <thead>
                <tr>
                    <th>Timestamp</th>
                    <th>Symbol</th>
                    <th class="text-center">Signal</th>
                    <th class="text-end">Confidence</th>
                    <th class="text-end">RSI</th>
                    <th class="text-end">Volatility</th>
                    <th class="text-end">Price</th>
                </tr>
            </thead>
            <tbody id="signalHistoryTable" data-table="signals" data-content>
                <tr>
                    <td colspan="7" class="text-center py-4">
                        <div class="loading-spinner text-primary" role="status">
                            <i class="fas fa-spinner fa-spin me-2"></i>
                            <span>Loading signal history from CSV...</span>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Signal Thresholds Reference -->
<div class="data-card">
    <h5 class="card-title">
        <i class="fas fa-sliders-h me-2"></i>Signal Thresholds
        <small class="text-muted ms-2">(Calibrated from backtest analysis)</small>
    </h5>
    <div class="row">
        <div class="col-md-3">
            <div class="text-center p-3 border rounded bg-success">
                <div class="h5"><i class="fas fa-arrow-up me-1"></i>≥65</div>
                <div>BUY Signal</div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="text-center p-3 border rounded bg-warning">
                <div class="h5"><i class="fas fa-eye me-1"></i>≥55</div>
                <div>CONSIDER Signal</div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="text-center p-3 border rounded bg-secondary">
                <div class="h5"><i class="fas fa-pause me-1"></i>≥45</div>
                <div>WAIT Signal</div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="text-center p-3 border rounded bg-danger">
                <div class="h5"><i class="fas fa-times me-1"></i>&lt;45</div>
                <div>AVOID Signal</div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let currentSymbol = 'BTC';
let signalData = null;
let currentPrice = null;

// Data normalization helpers for robust API response mapping
const DataMapper = {
    // Normalize hybrid signal response structure
    normalizeHybridSignal(data) {
        if (!data || typeof data !== 'object') {
            console.warn('⚠️ Invalid hybrid signal data received:', data);
            return this.getDefaultHybridSignal();
        }
        
        return {
            confidence_score: this.safeFloat(data.confidence_score, 0),
            timing_signal: this.safeString(data.timing_signal || data.final_signal, 'WAIT'),
            analysis_type: this.safeString(data.analysis_type, 'TRADITIONAL'),
            version: this.safeString(data.version, '1.0'),
            risk_level: this.safeString(data.risk_level, 'MEDIUM'),
            suggested_target_price: this.safeFloat(data.suggested_target_price, 0),
            ml_integration: this.normalizeMlIntegration(data.ml_integration || {}),
            enhanced_filters: this.normalizeEnhancedFilters(data.enhanced_filters || {}),
            system_info: this.normalizeSystemInfo(data.system_info || {})
        };
    },
    
    // Normalize ML integration data
    normalizeMlIntegration(data) {
        return {
            ml_enabled: Boolean(data.ml_enabled),
            ml_probability: this.safeFloat(data.ml_probability, 0.5),
            ml_confidence: this.safeFloat(data.ml_confidence, 0),
            ml_signal: this.safeString(data.ml_signal, 'UNAVAILABLE'),
            traditional_score: this.safeFloat(data.traditional_score, 0)
        };
    },
    
    // Normalize enhanced filters data
    normalizeEnhancedFilters(data) {
        return {
            technical_indicators: this.normalizeTechnicalIndicators(data.technical_indicators || {}),
            signals: this.normalizeSignals(data.signals || {})
        };
    },
    
    // Normalize technical indicators
    normalizeTechnicalIndicators(data) {
        return {
            rsi_14: this.safeFloat(data.rsi_14 || data.rsi, null),
            volatility_7: this.safeFloat(data.volatility_7 || data.volatility, null),
            volume_ratio: this.safeFloat(data.volume_ratio, null),
            momentum: this.safeFloat(data.momentum, null)
        };
    },
    
    // Normalize signal flags
    normalizeSignals(data) {
        return {
            momentum_positive: Boolean(data.momentum_positive),
            near_support: Boolean(data.near_support),
            bollinger_oversold: Boolean(data.bollinger_oversold),
            volume_above_average: Boolean(data.volume_above_average),
            trend_bullish: Boolean(data.trend_bullish)
        };
    },
    
    // Normalize system info
    normalizeSystemInfo(data) {
        return {
            description: this.safeString(data.description, 'Signal Analysis System'),
            formula: this.safeString(data.formula, 'N/A'),
            thresholds: data.thresholds || {
                'BUY': '≥65 (Strong confidence)',
                'CONSIDER': '≥55 (Moderate confidence)', 
                'WAIT': '≥45 (Weak confidence)',
                'AVOID': '<45 (Poor confidence)'
            }
        };
    },
    
    // Normalize current holdings data
    normalizeHoldingsData(data) {
        if (!data || !data.holdings || !Array.isArray(data.holdings)) {
            console.warn('⚠️ Invalid holdings data received:', data);
            return [];
        }
        
        return data.holdings.map(holding => ({
            symbol: this.safeString(holding.symbol, ''),
            current_price: this.safeFloat(holding.current_price, 0),
            quantity: this.safeFloat(holding.quantity, 0),
            value: this.safeFloat(holding.value, 0)
        }));
    },
    
    // Safe data type conversion helpers
    safeFloat(value, defaultValue = 0) {
        if (value === null || value === undefined) return defaultValue;
        const parsed = parseFloat(value);
        return isNaN(parsed) ? defaultValue : parsed;
    },
    
    safeString(value, defaultValue = '') {
        if (value === null || value === undefined) return defaultValue;
        return String(value);
    },
    
    // Default fallback data structures
    getDefaultHybridSignal() {
        return {
            confidence_score: 0,
            timing_signal: 'WAIT',
            analysis_type: 'UNAVAILABLE',
            version: '1.0',
            risk_level: 'HIGH',
            suggested_target_price: 0,
            ml_integration: {
                ml_enabled: false,
                ml_probability: 0.5,
                ml_confidence: 0,
                ml_signal: 'UNAVAILABLE',
                traditional_score: 0
            },
            enhanced_filters: {
                technical_indicators: {},
                signals: {}
            },
            system_info: {
                description: 'Signal system unavailable',
                formula: 'N/A',
                thresholds: {}
            }
        };
    }
};

async function loadSignalAnalysis() {
    const symbol = document.getElementById('symbolSelect').value;
    currentSymbol = symbol;
    
    try {
        updateStatus('loading', 'Analyzing signal...');
        showLoadingSkeletons();
        
        // Enhanced error handling with timeout protection
        const fetchWithTimeout = async (url, options = {}, timeout = 10000) => {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal,
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache',
                        ...options.headers
                    }
                });
                clearTimeout(id);
                return response;
            } catch (error) {
                clearTimeout(id);
                throw error;
            }
        };
        
        // Get current price from authentic OKX data with comprehensive error handling
        currentPrice = null;
        let priceSource = 'unknown';
        
        try {
            const priceResponse = await fetchWithTimeout('/api/current-holdings', {}, 8000);
            
            if (priceResponse.ok) {
                const rawHoldings = await priceResponse.json();
                const holdings = DataMapper.normalizeHoldingsData(rawHoldings);
                const holding = holdings.find(h => h.symbol === symbol);
                
                if (holding && holding.current_price > 0) {
                    currentPrice = holding.current_price;
                    priceSource = 'holdings';
                    console.log(`✅ Price from holdings: ${symbol} = $${currentPrice}`);
                } else {
                    console.warn(`⚠️ Symbol ${symbol} not found in holdings, trying market price`);
                }
            } else {
                console.warn(`⚠️ Holdings API error: ${priceResponse.status}`);
            }
        } catch (error) {
            console.warn(`⚠️ Holdings fetch failed: ${error.message}`);
        }
        
        // Fallback to market price API if needed
        if (!currentPrice || currentPrice <= 0) {
            try {
                const marketResponse = await fetchWithTimeout(`/api/market-price/${symbol}`, {}, 5000);
                if (marketResponse.ok) {
                    const marketData = await marketResponse.json();
                    if (marketData.price && marketData.price > 0) {
                        currentPrice = marketData.price;
                        priceSource = 'market';
                        console.log(`✅ Price from market: ${symbol} = $${currentPrice}`);
                    }
                }
            } catch (error) {
                console.warn(`⚠️ Market price fetch failed: ${error.message}`);
            }
        }
        
        // Enhanced validation with user-friendly error messages
        if (!currentPrice || currentPrice <= 0 || isNaN(currentPrice)) {
            throw new Error(`Unable to obtain current price for ${symbol}. Please check your connection and try again. The system requires live OKX price data for accurate signal analysis.`);
        }
        
        // Get hybrid signal data with robust error handling
        let rawSignalData = null;
        try {
            const signalResponse = await fetchWithTimeout(`/api/hybrid-signal?symbol=${symbol}&price=${currentPrice}`, {}, 10000);
            
            if (!signalResponse.ok) {
                const errorText = await signalResponse.text();
                throw new Error(`Signal API returned ${signalResponse.status}: ${errorText}`);
            }
            
            rawSignalData = await signalResponse.json();
            
            if (!rawSignalData) {
                throw new Error('Signal API returned empty response');
            }
            
            // Normalize and validate signal data
            signalData = DataMapper.normalizeHybridSignal(rawSignalData);
            
            // Add metadata for debugging
            signalData._metadata = {
                symbol,
                currentPrice,
                priceSource,
                timestamp: new Date().toISOString(),
                rawDataKeys: Object.keys(rawSignalData || {})
            };
            
            console.log(`✅ Signal data loaded for ${symbol}:`, {
                score: signalData.confidence_score,
                signal: signalData.timing_signal,
                mlEnabled: signalData.ml_integration?.ml_enabled,
                priceSource
            });
            
            displaySignalAnalysis(signalData);
            updateStatus('live', `Live data (${priceSource})`);
            showToast(`${symbol} signal analysis updated from ${priceSource} data`, 'success');
            
        } catch (error) {
            console.error(`❌ Signal data fetch failed for ${symbol}:`, error);
            throw new Error(`Signal analysis failed: ${error.message}`);
        }
        
        // Load real signal history from CSV with error handling
        try {
            await loadRealSignalHistory();
        } catch (error) {
            console.warn(`⚠️ Signal history loading failed: ${error.message}`);
            // Don't fail the entire operation if history fails
        }
        
        // Ensure loading skeletons are hidden after successful data load
        hideLoadingSkeletons();
        
    } catch (error) {
        console.error('Signal analysis loading failed:', error);
        updateStatus('error', 'Error loading');
        
        // Enhanced error display with actionable suggestions
        const userMessage = error.message.includes('price') 
            ? `Price data unavailable for ${symbol}. Please try a different symbol or check your connection.`
            : error.message.includes('Signal')
            ? `Signal analysis failed for ${symbol}. The system may be temporarily unavailable.`
            : `Failed to load ${symbol} analysis: ${error.message}`;
        
        showToast(userMessage, 'error');
        hideLoadingSkeletons();
        
        // Display fallback UI state
        displayErrorState(symbol, error.message);
    }
}

// Enhanced loading skeleton management with data attributes
function showLoadingSkeletons() {
    document.querySelectorAll('.loading-skeleton').forEach(skeleton => {
        skeleton.style.display = 'block';
        skeleton.parentElement?.setAttribute('data-loaded', 'false');
        skeleton.parentElement?.removeAttribute('data-error');
    });
    
    // Reset all data values to loading state
    document.querySelectorAll('[data-value]').forEach(element => {
        element.removeAttribute('data-value');
        element.setAttribute('data-loaded', 'false');
    });
    
    console.log('🔄 Loading skeletons shown');
}

function hideLoadingSkeletons() {
    document.querySelectorAll('.loading-skeleton').forEach(skeleton => {
        skeleton.style.display = 'none';
        skeleton.parentElement?.setAttribute('data-loaded', 'true');
    });
    
    console.log('✅ Loading skeletons hidden');
}

// Helper function to update indicator elements with data attributes
function updateIndicatorElement(elementId, value, indicator, formatter = null) {
    const element = document.getElementById(elementId);
    if (!element) {
        console.warn(`⚠️ Element ${elementId} not found`);
        return;
    }
    
    if (value != null && !isNaN(value)) {
        const displayValue = formatter ? formatter(value) : value;
        element.textContent = displayValue;
        element.setAttribute('data-value', value);
        element.setAttribute('data-indicator', indicator);
        element.setAttribute('data-loaded', 'true');
        element.removeAttribute('data-error');
    } else {
        element.textContent = '—';
        element.setAttribute('data-error', 'no-data');
        element.setAttribute('data-loaded', 'true');
        element.removeAttribute('data-value');
    }
}

// Helper function to update signal indicators with data attributes  
function updateSignalIndicator(elementId, value, signal) {
    const element = document.getElementById(elementId);
    if (!element) {
        console.warn(`⚠️ Signal element ${elementId} not found`);
        return;
    }
    
    const isPositive = Boolean(value);
    element.innerHTML = isPositive ? 
        '<i class="fas fa-check check-icon"></i>' : 
        '<i class="fas fa-times x-icon"></i>';
    element.setAttribute('data-signal', signal);
    element.setAttribute('data-value', isPositive);
    element.setAttribute('data-loaded', 'true');
}

// Error state display function
function displayErrorState(symbol, errorMessage) {
    console.log(`🚨 Displaying error state for ${symbol}:`, errorMessage);
    
    // Hide loading skeletons
    hideLoadingSkeletons();
    
    // Set error states on key elements
    const hybridScoreElement = document.getElementById('hybridScore');
    if (hybridScoreElement) {
        hybridScoreElement.textContent = '—';
        hybridScoreElement.setAttribute('data-error', 'load-failed');
        hybridScoreElement.setAttribute('data-loaded', 'false');
    }
    
    const signalBadgeElement = document.getElementById('signalBadge');
    if (signalBadgeElement) {
        signalBadgeElement.textContent = 'ERROR';
        signalBadgeElement.className = 'signal-badge bg-danger';
        signalBadgeElement.setAttribute('data-error', 'load-failed');
        signalBadgeElement.setAttribute('data-loaded', 'false');
    }
    
    // Clear progress bars
    ['traditionalFill', 'mlFill'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.style.width = '0%';
            element.setAttribute('data-error', 'load-failed');
        }
    });
    
    // Set error state for indicators
    ['rsiValue', 'volatilityValue', 'volumeValue'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = '—';
            element.setAttribute('data-error', 'load-failed');
            element.setAttribute('data-loaded', 'false');
        }
    });
    
    // Set error state for signal indicators
    ['momentumValue', 'supportValue', 'bollingerValue'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.innerHTML = '<i class="fas fa-exclamation-triangle text-danger"></i>';
            element.setAttribute('data-error', 'load-failed');
            element.setAttribute('data-loaded', 'false');
        }
    });
    
    // Update ML prediction with error state
    const mlProbabilityElement = document.getElementById('mlProbability');
    if (mlProbabilityElement) {
        mlProbabilityElement.textContent = '—';
        mlProbabilityElement.setAttribute('data-error', 'load-failed');
    }
    
    const mlDetailsElement = document.getElementById('mlDetails');
    if (mlDetailsElement) {
        mlDetailsElement.innerHTML = `
            <span class="text-danger">
                <i class="fas fa-exclamation-triangle me-2"></i>
                Analysis unavailable: ${errorMessage}
            </span>
        `;
        mlDetailsElement.setAttribute('data-error', 'load-failed');
    }
    
    console.log('🚨 Error state display completed');
}

function updateStatus(type, text) {
    const indicator = document.getElementById('statusIndicator');
    const iconMap = {
        loading: 'fas fa-spinner fa-spin',
        live: 'fas fa-circle',
        error: 'fas fa-exclamation-circle'
    };
    
    indicator.className = `status-indicator status-${type}`;
    indicator.innerHTML = `<i class="${iconMap[type]}"></i><span>${text}</span>`;
    
    // Update last updated timestamp
    document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString();
}

function displaySignalAnalysis(signal) {
    if (!signal) {
        console.error('❌ No signal data provided to displaySignalAnalysis');
        displayErrorState(currentSymbol, 'Invalid signal data received');
        return;
    }
    
    hideLoadingSkeletons();
    console.log('🎯 Displaying signal analysis:', signal);
    
    // Update hybrid score with data attributes and validation
    const hybridScore = DataMapper.safeFloat(signal.confidence_score, 0);
    const hybridScoreElement = document.getElementById('hybridScore');
    if (hybridScoreElement) {
        hybridScoreElement.textContent = hybridScore.toFixed(1);
        hybridScoreElement.setAttribute('data-value', hybridScore);
        hybridScoreElement.setAttribute('data-loaded', 'true');
        hybridScoreElement.setAttribute('data-symbol', currentSymbol);
    }
    
    // Update signal badge with enhanced validation
    const finalSignal = DataMapper.safeString(signal.timing_signal, 'WAIT');
    const badgeElement = document.getElementById('signalBadge');
    if (badgeElement) {
        badgeElement.textContent = finalSignal;
        badgeElement.setAttribute('data-signal', finalSignal);
        badgeElement.setAttribute('data-loaded', 'true');
        
        // Set badge color based on timing signal with enhanced mapping
        badgeElement.className = 'signal-badge ';
        const signalColorMap = {
            'BUY': 'bg-success',
            'STRONG_BUY': 'bg-success',
            'CONSIDER': 'bg-warning', 
            'HOLD': 'bg-secondary',
            'WAIT': 'bg-secondary',
            'AVOID': 'bg-danger',
            'SELL': 'bg-danger'
        };
        badgeElement.className += signalColorMap[finalSignal] || 'bg-secondary';
    }
    
    // Update score breakdown with enhanced data attributes
    const mlIntegration = signal.ml_integration || {};
    const traditionalScore = DataMapper.safeFloat(mlIntegration.traditional_score || signal.confidence_score, 0);
    const mlProbability = DataMapper.safeFloat(mlIntegration.ml_probability, 0.5);
    
    const traditionalElement = document.getElementById('traditionalScore');
    const mlElement = document.getElementById('mlScore');
    
    if (traditionalElement) {
        traditionalElement.textContent = traditionalScore.toFixed(1) + '%';
        traditionalElement.setAttribute('data-value', traditionalScore);
        traditionalElement.setAttribute('data-loaded', 'true');
    }
    
    if (mlElement) {
        mlElement.textContent = (mlProbability * 100).toFixed(1) + '%';
        mlElement.setAttribute('data-value', mlProbability * 100);
        mlElement.setAttribute('data-loaded', 'true');
    }
    
    // Animate progress bars with error handling
    setTimeout(() => {
        try {
            const traditionalFill = document.getElementById('traditionalFill');
            const mlFill = document.getElementById('mlFill');
            
            if (traditionalFill) {
                traditionalFill.style.width = Math.min(Math.max(traditionalScore, 0), 100) + '%';
                traditionalFill.setAttribute('data-value', traditionalScore);
            }
            
            if (mlFill) {
                const mlPercentage = Math.min(Math.max(mlProbability * 100, 0), 100);
                mlFill.style.width = mlPercentage + '%';
                mlFill.setAttribute('data-value', mlPercentage);
            }
        } catch (error) {
            console.warn('⚠️ Progress bar animation failed:', error);
        }
    }, 300);
    
    // Update technical indicators with comprehensive error handling
    const enhancedFilters = signal.enhanced_filters || {};
    const indicators = enhancedFilters.technical_indicators || {};
    
    // Enhanced indicator updates with data attributes
    updateIndicatorElement('rsiValue', indicators.rsi_14 || indicators.rsi, 'rsi', val => val?.toFixed(1));
    updateIndicatorElement('volatilityValue', indicators.volatility_7 || indicators.volatility, 'volatility', val => val?.toFixed(1) + '%');
    updateIndicatorElement('volumeValue', indicators.volume_ratio, 'volume', val => val?.toFixed(2));
    
    // Update signal indicators with enhanced error handling
    const signals = enhancedFilters.signals || {};
    updateSignalIndicator('momentumValue', signals.momentum_positive, 'momentum');
    updateSignalIndicator('supportValue', signals.near_support, 'support');
    updateSignalIndicator('bollingerValue', signals.bollinger_oversold, 'bollinger');
    
    // Update enhanced filters detail with validation
    if (enhancedFilters && typeof enhancedFilters === 'object' && Object.keys(enhancedFilters).length > 0) {
        try {
            displayEnhancedFilters(enhancedFilters);
        } catch (error) {
            console.warn('⚠️ Enhanced filters display failed:', error);
        }
    }
    
    // Update ML prediction with enhanced data attributes
    const mlProbabilityElement = document.getElementById('mlProbability');
    const mlDetailsElement = document.getElementById('mlDetails');
    
    if (mlProbabilityElement) {
        mlProbabilityElement.textContent = (mlProbability * 100).toFixed(1) + '%';
        mlProbabilityElement.setAttribute('data-value', mlProbability * 100);
        mlProbabilityElement.setAttribute('data-loaded', 'true');
    }
    
    if (mlDetailsElement) {
        const mlEnabled = Boolean(mlIntegration.ml_enabled);
        const mlSignal = DataMapper.safeString(mlIntegration.ml_signal, 'UNAVAILABLE');
        const mlConfidence = DataMapper.safeFloat(mlIntegration.ml_confidence, 0);
        const analysisType = DataMapper.safeString(signal.analysis_type, 'TRADITIONAL');
        
        mlDetailsElement.innerHTML = `
            <strong>ML Status:</strong> <span data-ml-enabled="${mlEnabled}">${mlEnabled ? '🟢 Active' : '🟡 Fallback'}</span><br>
            <strong>Signal:</strong> <span data-ml-signal="${mlSignal}">${mlSignal}</span><br>
            <strong>Confidence:</strong> <span data-ml-confidence="${mlConfidence}">${(mlConfidence * 100).toFixed(1)}%</span><br>
            <strong>Type:</strong> <span data-analysis-type="${analysisType}">${analysisType}</span>
        `;
        mlDetailsElement.setAttribute('data-loaded', 'true');
    }
    
    // Update system info with enhanced data attributes
    const systemInfoElement = document.getElementById('systemInfo');
    if (systemInfoElement) {
        const systemInfo = signal.system_info || {};
        const version = DataMapper.safeString(signal.version, 'N/A');
        const riskLevel = DataMapper.safeString(signal.risk_level, 'MEDIUM');
        const targetPrice = DataMapper.safeFloat(signal.suggested_target_price, 0);
        const formula = DataMapper.safeString(systemInfo.formula, 'N/A');
        
        systemInfoElement.innerHTML = `
            <div style="font-size: 0.9rem; line-height: 1.4;">
                <strong>Version:</strong> <span data-version="${version}">${version}</span><br>
                <strong>Risk Level:</strong> <span data-risk-level="${riskLevel}">${riskLevel}</span><br>
                <strong>Target Price:</strong> <span data-target-price="${targetPrice}">$${targetPrice.toLocaleString()}</span><br>
                <strong>Formula:</strong> <span data-formula="${formula}">${formula}</span>
            </div>
        `;
        systemInfoElement.setAttribute('data-loaded', 'true');
    }
    
    // Update last updated timestamp
    const lastUpdatedElement = document.getElementById('lastUpdated');
    if (lastUpdatedElement) {
        const timestamp = new Date().toLocaleTimeString();
        lastUpdatedElement.textContent = timestamp;
        lastUpdatedElement.setAttribute('data-timestamp', new Date().toISOString());
    }
    
    console.log('✅ Signal analysis display completed successfully');
}

function displayEnhancedFilters(filters) {
    const signals = filters.signals || {};
    const box = document.getElementById('enhancedFiltersBox');
    const content = document.getElementById('enhancedFiltersContent');
    
    let html = '';
    for (const [key, value] of Object.entries(signals)) {
        const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const icon = value ? '<i class="fas fa-check check-icon"></i>' : '<i class="fas fa-times x-icon"></i>';
        html += `<div class="signal-row"><span>${displayName}</span><span>${icon}</span></div>`;
    }
    
    if (html) {
        content.innerHTML = html;
        box.style.display = 'block';
    }
}

async function loadRealSignalHistory() {
    const historyTable = document.getElementById('signalHistoryTable');
    const historyCount = document.getElementById('historyCount');
    
    // Set loading state
    if (historyTable) {
        historyTable.innerHTML = '<tr><td colspan="7" class="text-center py-4"><i class="fas fa-spinner fa-spin me-2"></i>Loading signal history...</td></tr>';
    }
    if (historyCount) {
        historyCount.textContent = 'Loading...';
    }
    
    try {
        const response = await fetch('/signals_log.csv', {
            cache: 'no-cache',
            headers: {
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache'
            }
        });
        
        if (!response.ok) {
            throw new Error(`CSV API returned ${response.status}: ${response.statusText}`);
        }
        
        const csvText = await response.text();
        if (!csvText || csvText.trim().length === 0) {
            throw new Error('Empty CSV data received');
        }
        
        const lines = csvText.split('\n').filter(line => line.trim());
        
        if (lines.length <= 1) {
            if (historyTable) {
                historyTable.innerHTML = 
                    '<tr><td colspan="7" class="text-center py-4 text-muted">No signal history available yet</td></tr>';
            }
            if (historyCount) {
                historyCount.textContent = '0 signals';
            }
            return;
        }
        
        // Enhanced CSV parsing with validation
        const records = [];
        const maxRecords = 10;
        const startIndex = Math.max(1, lines.length - maxRecords); // Get most recent records
        
        for (let i = startIndex; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            try {
                const cols = line.split(',').map(col => col.trim().replace(/^"|"$/g, ''));
                
                if (cols.length < 5) {
                    console.warn(`⚠️ Skipping malformed CSV line: ${line}`);
                    continue;
                }
                
                const record = {
                    timestamp: cols[0] || '',
                    symbol: cols[1] || '',
                    price: DataMapper.safeFloat(cols[2], 0),
                    confidence: DataMapper.safeFloat(cols[3], 0),
                    signal: DataMapper.safeString(cols[4], 'WAIT'),
                    rsi: DataMapper.safeFloat(cols[5], 0),
                    volatility: DataMapper.safeFloat(cols[6], 0)
                };
                
                // Validate record has essential data
                if (record.symbol && record.timestamp) {
                    records.push(record);
                } else {
                    console.warn(`⚠️ Skipping invalid record:`, record);
                }
            } catch (parseError) {
                console.warn(`⚠️ Error parsing CSV line: ${line}`, parseError);
            }
        }
        
        // Sort records by timestamp (newest first)
        records.sort((a, b) => {
            try {
                const dateA = new Date(a.timestamp);
                const dateB = new Date(b.timestamp);
                return dateB.getTime() - dateA.getTime();
            } catch {
                return 0;
            }
        });
        
        console.log(`✅ Loaded ${records.length} signal history records`);
        
        displayRealSignalHistory(records);
        
        // Update count with data attributes
        if (historyCount) {
            historyCount.textContent = `${records.length} recent signals`;
            historyCount.setAttribute('data-count', records.length);
            historyCount.setAttribute('data-loaded', 'true');
        }
        
    } catch (error) {
        console.error('Signal history loading failed:', error);
        
        if (historyTable) {
            historyTable.innerHTML = `
                <tr><td colspan="7" class="text-center py-4 text-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Failed to load signal history: ${error.message}
                    <br><small class="text-muted mt-2 d-block">Please check your connection and try again</small>
                </td></tr>
            `;
            historyTable.setAttribute('data-error', 'load-failed');
        }
        
        if (historyCount) {
            historyCount.textContent = 'Error';
            historyCount.setAttribute('data-error', 'load-failed');
        }
    }
}

function displayRealSignalHistory(history) {
    const tbody = document.getElementById('signalHistoryTable');
    
    if (!tbody) {
        console.warn('⚠️ Signal history table element not found');
        return;
    }
    
    if (!history || history.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-muted">No signal history available yet</td></tr>';
        tbody.setAttribute('data-state', 'empty');
        return;
    }
    
    try {
        const signalColorMap = {
            'BUY': 'bg-success',
            'STRONG_BUY': 'bg-success',
            'CONSIDER': 'bg-warning',
            'HOLD': 'bg-secondary', 
            'WAIT': 'bg-secondary',
            'AVOID': 'bg-danger',
            'SELL': 'bg-danger'
        };
        
        const rows = history.map((record, index) => {
            try {
                // Enhanced timestamp formatting
                let timestamp = 'Invalid Date';
                try {
                    const date = new Date(record.timestamp);
                    if (!isNaN(date.getTime())) {
                        timestamp = date.toLocaleString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }
                } catch {
                    timestamp = record.timestamp.substring(0, 16); // Fallback
                }
                
                const signalClass = signalColorMap[record.signal] || 'bg-secondary';
                const confidence = DataMapper.safeFloat(record.confidence, 0);
                const rsi = DataMapper.safeFloat(record.rsi, 0);
                const volatility = DataMapper.safeFloat(record.volatility, 0);
                const price = DataMapper.safeFloat(record.price, 0);
                
                return `
                    <tr data-record-index="${index}" data-symbol="${record.symbol}" data-signal="${record.signal}">
                        <td data-field="timestamp">${timestamp}</td>
                        <td data-field="symbol"><strong>${record.symbol}</strong></td>
                        <td class="text-center" data-field="signal">
                            <span class="badge ${signalClass}" data-signal="${record.signal}">${record.signal}</span>
                        </td>
                        <td class="text-end" data-field="confidence" data-value="${confidence}">${confidence.toFixed(1)}</td>
                        <td class="text-end" data-field="rsi" data-value="${rsi}">${rsi.toFixed(1)}</td>
                        <td class="text-end" data-field="volatility" data-value="${volatility}">${volatility.toFixed(1)}%</td>
                        <td class="text-end" data-field="price" data-value="${price}">$${price.toLocaleString()}</td>
                    </tr>
                `;
            } catch (rowError) {
                console.warn(`⚠️ Error rendering history record:`, record, rowError);
                return `
                    <tr data-record-index="${index}" data-error="render-failed">
                        <td colspan="7" class="text-center py-2 text-muted">
                            <small><i class="fas fa-exclamation-triangle me-1"></i>Error displaying record</small>
                        </td>
                    </tr>
                `;
            }
        });
        
        tbody.innerHTML = rows.join('');
        tbody.setAttribute('data-state', 'loaded');
        tbody.setAttribute('data-count', history.length);
        tbody.removeAttribute('data-error');
        
        console.log(`✅ Displayed ${history.length} signal history records`);
        
    } catch (error) {
        console.error('Error displaying signal history:', error);
        tbody.innerHTML = `
            <tr><td colspan="7" class="text-center py-4 text-danger">
                <i class="fas fa-exclamation-triangle me-2"></i>
                Error displaying signal history
                <br><small class="text-muted mt-1">${error.message}</small>
            </td></tr>
        `;
        tbody.setAttribute('data-error', 'display-failed');
    }
}

async function refreshSignalData() {
    const refreshBtn = document.getElementById('refreshBtn');
    const originalText = refreshBtn.innerHTML;
    
    refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Refreshing...';
    refreshBtn.disabled = true;
    
    try {
        await loadSignalAnalysis();
    } finally {
        setTimeout(() => {
            refreshBtn.innerHTML = originalText;
            refreshBtn.disabled = false;
        }, 1000);
    }
}

async function exportSignalHistory() {
    try {
        showToast('Exporting signal history...', 'info');
        
        const response = await fetch('/signals_log.csv');
        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `signal_history_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showToast('Signal history exported successfully!', 'success');
        } else {
            throw new Error('Export failed');
        }
    } catch (error) {
        showToast('Error exporting signal history: ' + error.message, 'error');
    }
}

// Page-specific refresh function
window.refreshPageData = async function() {
    await loadSignalAnalysis();
};

// 🔧 ENHANCED SIGNALS ML DEBUG FUNCTIONS
const SignalsMLDebug = {
    inspectState() {
        TradingDebug.log('🧠 Signals ML State Inspection');
        TradingDebug.inspectState('currentSymbol', currentSymbol);
        TradingDebug.inspectState('currentPrice', currentPrice);
        TradingDebug.inspectState('lastSignalData', signalData);
    },
    
    async debugSignal(symbol = null) {
        const testSymbol = symbol || currentSymbol;
        const testPrice = currentPrice || null; // No hardcoded fallback
        
        if (!testPrice) {
            TradingDebug.log('❌ Cannot test signal without authentic price data');
            return null;
        }
        
        TradingDebug.log(`🧠 Testing signal for ${testSymbol} at $${testPrice}`);
        try {
            const response = await fetch(`/api/hybrid-signal?symbol=${testSymbol}&price=${testPrice}`);
            const data = await response.json();
            
            TradingDebug.log('🧠 Signal response:', data);
            return data;
        } catch (error) {
            TradingDebug.trackError(error, 'Signal Loading');
            return null;
        }
    },
    
    async testAPIs() {
        TradingDebug.log('🧠 Testing Signals ML APIs...');
        const endpoints = [
            '/api/hybrid-signal?symbol=BTC&price=114200',
            '/api/current-holdings',
            '/signals_log.csv'
        ];
        
        for (const endpoint of endpoints) {
            await TradingDebug.helpers.testAPI(endpoint);
        }
    },
    
    refreshSignals() {
        TradingDebug.log('🧠 Forcing signals refresh...');
        refreshSignalData();
    },
    
    analyzeSignal(signalData = null) {
        const data = signalData || window.lastSignalData;
        if (!data) {
            TradingDebug.log('No signal data to analyze');
            return;
        }
        
        TradingDebug.log('🧠 Signal Analysis:');
        console.group('🧠 Signal Breakdown');
        console.log('Confidence Score:', data.confidence_score);
        console.log('Timing Signal:', data.timing_signal);
        console.log('Analysis Type:', data.analysis_type);
        console.log('ML Integration:', data.ml_integration);
        console.log('Enhanced Filters:', data.enhanced_filters);
        console.log('System Info:', data.system_info);
        console.groupEnd();
    }
};

// Add to global scope
window.signalsMLDebug = SignalsMLDebug;

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    loadSignalAnalysis();
    
    // Auto-refresh every 3 minutes
    setInterval(loadSignalAnalysis, 180000);
});

// ================================
// MISSING UTILITY FUNCTIONS  
// ================================

// Toast notification system
let toastContainer = null;

function initToastContainer() {
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 350px;
        `;
        document.body.appendChild(toastContainer);
    }
}

function showToast(message, type = 'info', duration = 4000) {
    initToastContainer();
    
    const toast = document.createElement('div');
    toast.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show`;
    toast.style.cssText = `
        margin-bottom: 10px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        animation: slideInRight 0.3s ease;
    `;
    
    const iconMap = {
        'success': 'fas fa-check-circle',
        'error': 'fas fa-exclamation-triangle', 
        'info': 'fas fa-info-circle',
        'warning': 'fas fa-exclamation-triangle'
    };
    
    toast.innerHTML = `
        <i class="${iconMap[type] || iconMap.info} me-2"></i>
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    toastContainer.appendChild(toast);
    
    // Auto dismiss
    setTimeout(() => {
        if (toast.parentNode) {
            toast.remove();
        }
    }, duration);
    
    return toast;
}

// Modal popup system
function showPopup(title, content, type = 'info') {
    let modal = document.getElementById('dynamicModal');
    
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'dynamicModal';
        modal.className = 'modal fade';
        modal.innerHTML = `
            <div class="modal-dialog modal-lg">
                <div class="modal-content bg-dark text-light">
                    <div class="modal-header">
                        <h5 class="modal-title" id="dynamicModalTitle"></h5>
                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body" id="dynamicModalContent"></div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    document.getElementById('dynamicModalTitle').textContent = title;
    document.getElementById('dynamicModalContent').innerHTML = content;
    
    const bootstrapModal = new bootstrap.Modal(modal);
    bootstrapModal.show();
    
    return bootstrapModal;
}

// Add CSS animations
const style = document.createElement('style');
style.textContent = `
    @keyframes slideInRight {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
`;
document.head.appendChild(style);

</script>
{% endblock %}
