{% extends "base_layout.html" %}

{% block title %}Backtest Results - Grim Trader v2.0{% endblock %}
{% block page_title %}Backtest Results{% endblock %}
{% block page_subtitle %}Performance validation of hybrid signals against real OKX trade history{% endblock %}

{% block extra_css %}
<style>
.performance-summary {
    background: linear-gradient(135deg, var(--success-green), var(--accent-blue));
    border-radius: 15px;
    padding: 30px;
    margin-bottom: 30px;
    border: 2px solid var(--border-color);
}

.performance-metric {
    text-align: center;
    padding: 20px;
}

.metric-value {
    font-size: 2.5rem;
    font-weight: 800;
    margin: 10px 0;
}

.metric-label {
    color: #e9ecef;
    font-size: 1rem;
    font-weight: 500;
}

.backtest-chart {
    background: var(--primary-dark);
    border-radius: 10px;
    padding: 20px;
    border: 1px solid var(--border-color);
}

.signal-performance-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin: 25px 0;
}

.signal-performance-card {
    background: var(--primary-dark);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 20px;
    text-align: center;
}

.results-table {
    background: var(--primary-dark);
    border-radius: 10px;
    overflow: hidden;
}

/* Enhanced Loading Animations */
.loading-skeleton {
    background: linear-gradient(90deg, 
        rgba(156, 163, 175, 0.1) 25%, 
        rgba(156, 163, 175, 0.2) 50%, 
        rgba(156, 163, 175, 0.1) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    border-radius: 4px;
    height: 1.2em;
}

.loading-skeleton-metric {
    background: linear-gradient(90deg, 
        rgba(255, 255, 255, 0.1) 25%, 
        rgba(255, 255, 255, 0.3) 50%, 
        rgba(255, 255, 255, 0.1) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    border-radius: 8px;
    height: 2.5rem;
    width: 85%;
    margin: 10px auto;
}

@keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
}

.metric-loading {
    opacity: 0.7;
    transform: scale(0.98);
    transition: all 0.3s ease;
}

.metric-loaded {
    opacity: 1;
    transform: scale(1);
    animation: metricPulse 0.6s ease-out;
}

@keyframes metricPulse {
    0% { transform: scale(0.95); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.status-indicator {
    font-size: 0.8rem;
    color: #9ca3af;
    margin-top: 10px;
    text-align: center;
    transition: color 0.3s ease;
}

.status-loading { color: #f59e0b; }
.status-loaded { color: #22c55e; }
.status-error { color: #ef4444; }
</style>
{% endblock %}

{% block content %}
<!-- Performance Summary -->
<div class="performance-summary">
    <div class="row">
        <div class="col-md-3">
            <div class="performance-metric">
                <div class="metric-value text-white" id="avgPnL">
                    <div class="loading-skeleton loading-skeleton-metric"></div>
                </div>
                <div class="metric-label">Average P&L</div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="performance-metric">
                <div class="metric-value text-white" id="winRate">
                    <div class="loading-skeleton loading-skeleton-metric"></div>
                </div>
                <div class="metric-label">Win Rate</div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="performance-metric">
                <div class="metric-value text-white" id="matchRate">
                    <div class="loading-skeleton loading-skeleton-metric"></div>
                </div>
                <div class="metric-label">Match Rate</div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="performance-metric">
                <div class="metric-value text-white" id="totalTrades">
                    <div class="loading-skeleton loading-skeleton-metric"></div>
                </div>
                <div class="metric-label">Total Trades</div>
            </div>
        </div>
    </div>
    <div class="status-indicator status-loading" id="backtest-status">Loading backtest data...</div>
</div>

<!-- Control Panel -->
<div class="data-card mb-4">
    <div class="row align-items-center">
        <div class="col-md-6">
            <h5 class="mb-0">Backtest Analysis Controls</h5>
            <p style="color: #9ca3af;" class="mb-0">Run new backtest or export current results</p>
        </div>
        <div class="col-md-6 text-end">
            <button class="btn btn-success me-2" onclick="runNewBacktest()" title="Runs a fresh backtest analysis on recent trade data using the current ML models and technical indicators">
                <i class="fas fa-play me-2"></i>Run New Backtest
            </button>
            <button class="btn btn-outline-primary me-2" onclick="exportBacktestResults()" title="Downloads current backtest results as a CSV file for external analysis in Excel or other tools">
                <i class="fas fa-download me-1"></i>Export CSV
            </button>
            <button class="btn btn-outline-secondary" onclick="refreshBacktestData()" title="Refreshes all charts and metrics with the latest trade data and recalculates performance statistics">
                <i class="fas fa-sync me-1"></i>Refresh
            </button>
        </div>
    </div>
</div>

<!-- Performance by Signal Type -->
<div class="data-card">
    <h5 class="card-title">
        <i class="fas fa-chart-pie"></i>
        Performance by Signal Type
    </h5>
    
    <div class="signal-performance-grid" id="signalPerformanceGrid">
        <div class="signal-performance-card" title="BUY signals: Strong upward momentum trades. Shows total P&L and win rate for all positions entered on BUY signals from the trading algorithm.">
            <div class="h4 text-success">BUY</div>
            <div class="h3 text-success" id="buyPnL">
                <div class="loading-skeleton loading-skeleton-metric"></div>
            </div>
            <div style="color: #9ca3af;" id="buyStats">Loading authentic data...</div>
        </div>
        <div class="signal-performance-card" title="CONSIDER signals: SELL signals mapped to CONSIDER card. Shows performance for positions that were closed or avoided based on bearish momentum indicators.">
            <div class="h4 text-warning">CONSIDER</div>
            <div class="h3 text-warning" id="considerPnL">
                <div class="loading-skeleton loading-skeleton-metric"></div>
            </div>
            <div style="color: #9ca3af;" id="considerStats">Loading authentic data...</div>
        </div>
        <div class="signal-performance-card" title="Risk & Efficiency: Max Drawdown shows largest peak-to-trough loss. Profit Factor is gross profits √∑ gross losses. Sharpe Ratio measures risk-adjusted returns.">
            <div class="h4 text-warning">RISK & EFFICIENCY</div>
            <div class="h3 text-warning" id="riskPnL">
                <div class="loading-skeleton loading-skeleton-metric"></div>
            </div>
            <div style="color: #9ca3af;" id="riskStats">Loading risk metrics...</div>
        </div>
        <div class="signal-performance-card" title="Market Regime: Performance analysis across different time periods. Compares early vs recent trading performance to identify changing market conditions.">
            <div class="h4 text-info">MARKET REGIME</div>
            <div class="h3 text-info" id="regimePnL">
                <div class="loading-skeleton loading-skeleton-metric"></div>
            </div>
            <div style="color: #9ca3af;" id="regimeStats">Loading regime analysis...</div>
        </div>
    </div>
</div>

<!-- P&L Distribution Chart -->
<div class="row mb-4">
    <div class="col-lg-8">
        <div class="data-card" title="P&L Distribution: Histogram showing frequency of profit/loss outcomes. Helps identify if the strategy has consistent small wins or relies on few large wins.">
            <h5 class="card-title">
                <i class="fas fa-chart-line"></i>
                P&L Distribution
            </h5>
            <div class="backtest-chart">
                <canvas id="pnlChart" width="400" height="200"></canvas>
            </div>
        </div>
    </div>
    <div class="col-lg-4">
        <div class="data-card" title="ML vs Traditional: Compares machine learning predictions with traditional technical analysis. Shows correlation between ML probability scores and actual trade outcomes.">
            <h5 class="card-title">
                <i class="fas fa-brain"></i>
                ML vs Traditional
            </h5>
            <div class="text-center py-4">
                <div class="h4 text-info" id="correlation">
                    <div class="loading-skeleton loading-skeleton-metric"></div>
                </div>
                <div style="color: #9ca3af;" class="mb-3" id="correlationDesc">Loading ML correlation analysis...</div>
                <div class="h5 text-warning">ML Contribution: 40%</div>
                <div style="color: #9ca3af;" class="mb-3" id="mlCorrelation">Loading ML probability correlation...</div>
                <div class="h5 text-success">Traditional: 60%</div>
                <div style="color: #9ca3af;">Technical analysis weight</div>
            </div>
        </div>
    </div>
</div>

<!-- Dynamic Weighting System -->
<div class="row mb-4">
    <div class="col-lg-12">
        <div class="data-card" title="Dynamic Weighting System: Advanced ML/TA hybrid signal system that automatically recalibrates weights based on rolling correlation with actual P&L outcomes. Ensures optimal balance between machine learning and technical analysis.">
            <h5 class="card-title">
                <i class="fas fa-balance-scale"></i>
                Dynamic ML/TA Weighting System
                <span class="badge bg-success ms-2">LIVE</span>
            </h5>
            <div class="row">
                <div class="col-md-3">
                    <div class="text-center py-3">
                        <div class="h4 text-primary" id="dynamicMLWeight">
                            <div class="loading-skeleton loading-skeleton-metric"></div>
                        </div>
                        <div style="color: #9ca3af;">ML Weight</div>
                        <small class="text-muted" id="mlCorrelationValue">Loading...</small>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="text-center py-3">
                        <div class="h4 text-success" id="dynamicTAWeight">
                            <div class="loading-skeleton loading-skeleton-metric"></div>
                        </div>
                        <div style="color: #9ca3af;">TA Weight</div>
                        <small class="text-muted" id="taCorrelationValue">Loading...</small>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="text-center py-3">
                        <div class="h4 text-warning" id="dynamicSampleSize">
                            <div class="loading-skeleton loading-skeleton-metric"></div>
                        </div>
                        <div style="color: #9ca3af;">Sample Size</div>
                        <small class="text-muted">Rolling window: 50 trades</small>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="text-center py-3">
                        <div class="h4" id="dynamicStatus">
                            <div class="loading-skeleton loading-skeleton-metric"></div>
                        </div>
                        <div style="color: #9ca3af;">System Status</div>
                        <small class="text-muted" id="dynamicStatusDesc">Initializing...</small>
                    </div>
                </div>
            </div>
            <div class="mt-3 p-3 rounded" style="background: rgba(0,123,255,0.1); border-left: 4px solid #007bff;">
                <small class="text-info">
                    <i class="fas fa-info-circle me-1"></i>
                    <strong>How it works:</strong> This system continuously monitors the correlation between ML predictions and actual trade outcomes vs Technical Analysis indicators and actual results. When ML predictions become more accurate, ML weight increases (max 80%). When TA performs better, TA weight increases. This ensures optimal signal quality as market conditions change.
                </small>
            </div>
        </div>
    </div>
</div>

<!-- Detailed Results Table -->
<div class="data-card">
    <h5 class="card-title">
        <i class="fas fa-chart"></i>
        Detailed Backtest Results
        <span class="badge bg-primary ms-2" id="resultsCount">Loading...</span>
    </h5>
    
    <div class="table-responsive results-table">
        <table class="table-v02" style="--v02-head-bg: #6c7ae0;" id="backtestTable">
            <thead>
                <tr>
                    <th title="When the trading signal was generated based on market analysis">Timestamp</th>
                    <th title="Cryptocurrency trading pair (e.g., BTC, ETH, TRX)">Symbol</th>
                    <th class="text-center" title="Trading action: BUY (strong bullish), CONSIDER (mixed signals), WAIT (bearish), AVOID (high risk)">Signal</th>
                    <th class="text-end" title="Overall signal strength combining ML predictions and technical analysis (0-100%)">Confidence</th>
                    <th class="text-end" title="Machine learning model probability prediction for price direction (0.1-0.9)">ML Prob</th>
                    <th class="text-end" title="Price when the signal was generated (signal candle close price)">Signal Price</th>
                    <th class="text-end" title="Price when trade would be executed (next candle open price using T+1 model)">Exec Price</th>
                    <th class="text-end" title="Profit/Loss in dollar amount based on position size and price movement">P&L $</th>
                    <th class="text-end" title="Percentage return based on entry price vs current/exit price">P&L %</th>
                    <th class="text-center" title="YES: execution price within 0.1% tolerance of signal price. NO: significant slippage occurred">Match</th>
                </tr>
            </thead>
            <tbody id="backtestTableBody">
                <tr>
                    <td colspan="10" class="text-center py-4">
                        <div class="loading-spinner text-primary" role="status">
                            <span class="visually-hidden">Loading backtest results...</span>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Best & Worst Trades -->
<div class="row">
    <div class="col-lg-6">
        <div class="data-card" title="Top 5 Best Trades: Shows the most profitable trades ranked by percentage return. Helps identify what conditions lead to successful trades.">
            <h5 class="card-title text-success">
                <i class="fas fa-trophy"></i>
                Top 5 Best Trades
            </h5>
            <div id="bestTrades" class="text-center py-4">
                <div class="loading-spinner text-success" role="status">
                    <span class="visually-hidden">Loading best trades...</span>
                </div>
            </div>
        </div>
    </div>
    <div class="col-lg-6">
        <div class="data-card" title="Bottom 5 Trades: Shows the worst performing trades by percentage loss. Helps identify patterns to avoid and improve risk management.">
            <h5 class="card-title text-warning">
                <i class="fas fa-chart-line"></i>
                Bottom 5 Trades
            </h5>
            <div id="worstTrades" class="text-center py-4">
                <div class="loading-spinner text-warning" role="status">
                    <span class="visually-hidden">Loading worst trades...</span>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
console.log('üîß Backtest JS loaded');
window.onerror = (m, s, l, c, e) => console.error('JS error:', m, s, l, c, e);

let backtestResults = null;
let pnlChart = null;

// Removed duplicate CSV-based loadBacktestResults function - using API-based version below

function parseCSV(csvText) {
    const lines = csvText.split('\n');
    const headers = lines[0].split(',');
    const results = [];
    
    for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim()) {
            const values = lines[i].split(',');
            const row = {};
            headers.forEach((header, index) => {
                row[header.trim()] = values[index]?.trim();
            });
            results.push(row);
        }
    }
    
    return results;
}

function loadSampleBacktestData() {
    // ‚ùå REMOVED: No sample data - authentic backtest results only
    console.error('‚ùå DATA INTEGRITY: Sample data removed - authentic backtest data required from ML system');
    
    // Show error message instead of fake data
    document.getElementById('backtestTableBody').innerHTML = 
        '<tr><td colspan="10" class="text-center py-4 text-warning">' +
        '<i class="fas fa-exclamation-triangle me-2"></i>' +
        'No authentic backtest results available. Run a new backtest to generate real ML data.' +
        '</td></tr>';
}

async function loadBacktestResults() {
    try {
        console.log('üîÑ Loading backtest results from performance charts API...');
        
        // Update status to loading
        const statusElement = document.getElementById('backtest-status');
        if (statusElement) {
            statusElement.textContent = 'Loading backtest data...';
            statusElement.className = 'status-indicator status-loading';
        }
        
        // Fetch performance chart data (which includes backtest results)
        const response = await fetch('/api/public/backtest');
        if (!response.ok) {
            throw new Error(`Failed to fetch performance data: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success && data.results && data.results.length > 0) {
            console.log('‚úÖ Performance chart data loaded:', data.results.length, 'results');
            
            // Store data globally
            window.backtestData = data.results;
            window.backtestSummary = data.summary;
            
            // Update all UI components with the new data - chart first, then stats
            updateResultsTable(data.results);
            updatePnLChart(data.results);
            updateBestWorstTrades(data.results);
            
            // Update summary stats with error handling for correlation
            try {
                updateSummaryStats(data.results);
            } catch (error) {
                console.error('‚ùå Error in summary stats (correlation):', error);
            }
            
            // Display the results
            displayBacktestResults(data.results);
            
            // Update status to success
            if (statusElement) {
                const now = new Date();
                statusElement.textContent = `Last updated: ${now.toLocaleTimeString()}`;
                statusElement.className = 'status-indicator status-loaded';
            }
            
            console.log('‚úÖ Backtest results displayed successfully');
            
        } else {
            console.warn('No backtest results available from API');
            
            // Show empty state
            document.getElementById('backtestTableBody').innerHTML = 
                '<tr><td colspan="10" class="text-center py-4 text-warning">' +
                '<i class="fas fa-info-circle me-2"></i>' +
                'No backtest results available. Run a new backtest to generate data.' +
                '</td></tr>';
            
            // Update status
            if (statusElement) {
                statusElement.textContent = 'No backtest data available';
                statusElement.className = 'status-indicator status-warning';
            }
        }
        
    } catch (error) {
        console.error('‚ùå Backtest results loading failed:', error);
        
        // Update status to error
        const statusElement = document.getElementById('backtest-status');
        if (statusElement) {
            statusElement.textContent = 'Error loading data';
            statusElement.className = 'status-indicator status-error';
        }
        
        // Show error in table
        document.getElementById('backtestTableBody').innerHTML = 
            '<tr><td colspan="10" class="text-center py-4 text-danger">' +
            '<i class="fas fa-exclamation-triangle me-2"></i>' +
            'Error loading backtest results. Please try again.' +
            '</td></tr>';
        
        // Still show fallback chart for no data case
        updatePnLChart([]);
    }
}

// Removed redundant updateStatusCards function - updateSummaryStats handles this correctly

function displayBacktestResults(results) {
    if (!results || results.length === 0) {
        document.getElementById('backtestTableBody').innerHTML = 
            '<tr><td colspan="10" class="text-center py-4">No backtest results available</td></tr>';
        return;
    }
    
    // Update summary statistics
    updateSummaryStats(results);
    
    // Update results table
    updateResultsTable(results);
    
    // Update best/worst trades
    updateBestWorstTrades(results);
    
    // Update P&L chart
    updatePnLChart(results);
}

function updateSummaryStats(results) {
    // Use summary data from global variable if available, otherwise calculate from results
    if (window.backtestSummary) {
        const summary = window.backtestSummary;
        
        // Update main display using summary data from API with error checking
        const avgPnLEl = document.getElementById('avgPnL');
        if (avgPnLEl) avgPnLEl.textContent = Number(summary.avg_pnl_percent || 0).toFixed(2) + '%';
        
        const winRateEl = document.getElementById('winRate');
        if (winRateEl) winRateEl.textContent = Number(summary.win_rate || 0).toFixed(1) + '%';
        
        const matchRateEl = document.getElementById('matchRate');
        if (matchRateEl) matchRateEl.textContent = '100%'; // All results are matched since they come from real trades
        
        const totalTradesEl = document.getElementById('totalTrades');
        if (totalTradesEl) totalTradesEl.textContent = summary.total_trades || 0;
        
        console.log('‚úÖ Status cards updated with API summary data');
    } else {
        // Fallback: calculate from results (if in old format)
        const matchedResults = results.filter(r => r.matched === true || r.matched === 'True');
        
        if (matchedResults.length === 0) {
            // Use all results if no matched field
            const allResults = results;
            const pnlValues = allResults.map(r => parseFloat(r['pnl_%'] || r['pnl_percent'] || 0));
            const avgPnL = pnlValues.length > 0 ? pnlValues.reduce((a, b) => a + b, 0) / pnlValues.length : 0;
            const winningTrades = pnlValues.filter(p => p > 0).length;
            const winRate = pnlValues.length > 0 ? (winningTrades / pnlValues.length) * 100 : 0;
            
            // Update main display
            document.getElementById('avgPnL').textContent = avgPnL.toFixed(2) + '%';
            document.getElementById('winRate').textContent = winRate.toFixed(1) + '%';
            document.getElementById('matchRate').textContent = '100%';
            document.getElementById('totalTrades').textContent = allResults.length;
        } else {
            // Use matched results
            const pnlValues = matchedResults.map(r => parseFloat(r['pnl_%'] || r['pnl_percent'] || 0));
            const avgPnL = pnlValues.reduce((a, b) => a + b, 0) / pnlValues.length;
            const winningTrades = pnlValues.filter(p => p > 0).length;
            const winRate = (winningTrades / pnlValues.length) * 100;
            const matchRate = (matchedResults.length / results.length) * 100;
            
            // Update main display
            document.getElementById('avgPnL').textContent = avgPnL.toFixed(2) + '%';
            document.getElementById('winRate').textContent = winRate.toFixed(1) + '%';
            document.getElementById('matchRate').textContent = matchRate.toFixed(1) + '%';
            document.getElementById('totalTrades').textContent = matchedResults.length;
        }
    }
    
    // Update signal performance cards with authentic data
    updateSignalTypePerformance(results);
    
    // Update ML correlation analysis with authentic data
    updateMLCorrelationAnalysis(results);
}

function updateSignalTypePerformance(results) {
    console.log('üîÑ Updating signal type performance with results:', results.length);
    
    // Check what signal types actually exist in the data
    const actualSignals = [...new Set(results.map(r => r.signal))];
    console.log('üìä Actual signals in data:', actualSignals);
    
    // Map actual signals to display cards
    const signalMappings = {
        'BUY': { element: 'buy', label: 'BUY' },
        'CAUTIOUS_BUY': { element: 'buy', label: 'CAUTIOUS BUY' },  // Map CAUTIOUS_BUY to BUY card
        'SELL': { element: 'consider', label: 'SELL' },  // Map SELL to CONSIDER card
        'CONSIDER': { element: 'consider', label: 'CONSIDER' },
        'WAIT': { element: 'consider', label: 'WAIT' },  // Map WAIT to CONSIDER card
        'AVOID': { element: 'consider', label: 'AVOID' }  // Map AVOID to CONSIDER card for display
    };
    
    // Clear signal cards first
    ['buy', 'consider'].forEach(cardType => {
        const pnlElement = document.getElementById(cardType + 'PnL');
        const statsElement = document.getElementById(cardType + 'Stats');
        if (pnlElement) pnlElement.textContent = 'N/A';
        if (statsElement) statsElement.textContent = 'No trades';
    });
    
    // Update cards based on actual signals
    actualSignals.forEach(signal => {
        const mapping = signalMappings[signal];
        if (mapping) {
            const signalResults = results.filter(r => r.signal === signal);
            console.log(`üìä Signal ${signal} (${mapping.label}): ${signalResults.length} trades`);
            
            if (signalResults.length > 0) {
                const pnlValues = signalResults.map(r => parseFloat(r['pnl_%'] || 0));
                const avgPnL = pnlValues.reduce((a, b) => a + b, 0) / pnlValues.length;
                const winningTrades = pnlValues.filter(p => p > 0).length;
                const winRate = (winningTrades / pnlValues.length) * 100;
                
                const elementId = mapping.element + 'PnL';
                const statsId = mapping.element + 'Stats';
                
                const pnlElement = document.getElementById(elementId);
                const statsElement = document.getElementById(statsId);
                
                if (pnlElement && statsElement) {
                    pnlElement.textContent = avgPnL.toFixed(2) + '%';
                    statsElement.textContent = `${signalResults.length} ${mapping.label} trades ‚Ä¢ ${winRate.toFixed(0)}% win rate`;
                    console.log(`‚úÖ Updated ${mapping.label}: ${avgPnL.toFixed(2)}% (${signalResults.length} trades)`);
                } else {
                    console.error(`‚ùå Elements not found for ${mapping.label}: ${elementId}, ${statsId}`);
                }
            }
        } else {
            console.warn(`‚ö†Ô∏è Unknown signal type: ${signal}`);
        }
    });
    
    console.log('‚úÖ Signal type performance update completed');
    
    // Update risk & efficiency and market regime cards
    updateRiskAndRegimeCards(results);
}

function updateRiskAndRegimeCards(results) {
    console.log('üîÑ Updating risk and regime cards...');
    
    if (!results || results.length === 0) {
        console.warn('‚ö†Ô∏è No results data for risk analysis');
        return;
    }
    
    // Calculate Risk & Efficiency metrics
    const pnlValues = results.map(r => parseFloat(r['pnl_%'] || 0));
    const pnlDollar = results.map(r => parseFloat(r['pnl_$'] || 0));
    
    // Max Drawdown calculation
    let cumulativePnL = 0;
    let peak = 0;
    let maxDrawdown = 0;
    
    pnlValues.forEach(pnl => {
        cumulativePnL += pnl;
        if (cumulativePnL > peak) {
            peak = cumulativePnL;
        }
        const drawdown = peak - cumulativePnL;
        if (drawdown > maxDrawdown) {
            maxDrawdown = drawdown;
        }
    });
    
    // Profit Factor calculation
    const grossProfit = pnlDollar.filter(p => p > 0).reduce((a, b) => a + b, 0);
    const grossLoss = Math.abs(pnlDollar.filter(p => p < 0).reduce((a, b) => a + b, 0));
    const profitFactor = grossLoss > 0 ? (grossProfit / grossLoss) : (grossProfit > 0 ? '‚àû' : '0');
    
    // Sharpe ratio (simplified per-trade)
    const avgPnL = pnlValues.reduce((a, b) => a + b, 0) / pnlValues.length;
    const stdDev = Math.sqrt(pnlValues.reduce((a, b) => a + Math.pow(b - avgPnL, 2), 0) / pnlValues.length);
    const sharpe = stdDev > 0 ? (avgPnL / stdDev) : 0;
    
    // Update Risk & Efficiency card
    const riskElement = document.getElementById('riskPnL');
    const riskStatsElement = document.getElementById('riskStats');
    
    if (riskElement && riskStatsElement) {
        riskElement.textContent = `${maxDrawdown.toFixed(2)}%`;
        riskStatsElement.innerHTML = `Max DD ‚Ä¢ PF: ${typeof profitFactor === 'number' ? profitFactor.toFixed(2) : profitFactor} ‚Ä¢ Sharpe: ${sharpe.toFixed(2)}`;
        console.log('‚úÖ Updated Risk & Efficiency card');
    }
    
    // Market Regime Performance (simplified - just by time periods)
    const winningTrades = pnlValues.filter(p => p > 0).length;
    const totalTrades = pnlValues.length;
    const winRate = (winningTrades / totalTrades) * 100;
    
    // Simple regime: first half vs second half of trades (proxy for changing market conditions)
    const halfPoint = Math.floor(totalTrades / 2);
    const firstHalf = pnlValues.slice(0, halfPoint);
    const secondHalf = pnlValues.slice(halfPoint);
    
    const firstHalfWinRate = firstHalf.filter(p => p > 0).length / firstHalf.length * 100;
    const secondHalfWinRate = secondHalf.filter(p => p > 0).length / secondHalf.length * 100;
    
    const firstHalfAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
    const secondHalfAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
    
    // Update Market Regime card
    const regimeElement = document.getElementById('regimePnL');
    const regimeStatsElement = document.getElementById('regimeStats');
    
    if (regimeElement && regimeStatsElement) {
        const bestPeriod = firstHalfAvg > secondHalfAvg ? 'Early' : 'Recent';
        regimeElement.textContent = `${bestPeriod} Period`;
        regimeStatsElement.innerHTML = `Early: ${firstHalfWinRate.toFixed(0)}% WR ‚Ä¢ Recent: ${secondHalfWinRate.toFixed(0)}% WR`;
        console.log('‚úÖ Updated Market Regime card');
    }
    
    console.log('‚úÖ Risk and regime cards update completed');
}

function updateMLCorrelationAnalysis(results) {
    // Calculate correlation between ML probability and P&L
    const mlProbs = results.map(r => parseFloat(r.ml_probability || 0));
    const pnlValues = results.map(r => parseFloat(r['pnl_%'] || 0));
    
    const correlation = calculateCorrelation(mlProbs, pnlValues);
    
    document.getElementById('correlation').textContent = `Correlation: ${correlation.toFixed(2)}`;
    
    const description = correlation > 0.5 ? 'Strong positive correlation' :
                       correlation > 0.2 ? 'Moderate positive correlation' :
                       correlation > -0.2 ? 'Weak correlation' :
                       correlation > -0.5 ? 'Moderate negative correlation' :
                       'Strong negative correlation';
    
    document.getElementById('correlationDesc').textContent = `${description} between ML probability and P&L`;
    document.getElementById('mlCorrelation').textContent = `ML probability correlation: ${correlation.toFixed(2)}`;
}

function calculateCorrelation(x, y) {
    const n = Math.min(x.length, y.length);
    if (n < 2) return 0;
    
    let sx = 0, sy = 0, sxy = 0, sxx = 0, syy = 0;
    
    for (let i = 0; i < n; i++) {
        const xi = Number(x[i]) || 0;
        const yi = Number(y[i]) || 0;
        sx += xi;
        sy += yi;
        sxy += xi * yi;
        sxx += xi * xi;
        syy += yi * yi;
    }
    
    const cov = n * sxy - sx * sy;
    const varX = n * sxx - sx * sx;
    const varY = n * syy - sy * sy;
    
    return (varX <= 0 || varY <= 0) ? 0 : cov / Math.sqrt(varX * varY);
}

function updateResultsTable(results) {
    const tbody = document.getElementById('backtestTableBody');
    document.getElementById('resultsCount').textContent = results.length;
    
    tbody.innerHTML = results.map(result => {
        const pnl = parseFloat(result['pnl_%'] || 0);
        const matched = result.matched === true || result.matched === 'true' || result.matched === 'True';
        
        let signalClass = 'bg-secondary';
        if (result.signal === 'BUY') signalClass = 'bg-success';
        else if (result.signal === 'CAUTIOUS_BUY') signalClass = 'bg-info';  // Light blue for cautious buy
        else if (result.signal === 'CONSIDER') signalClass = 'bg-warning';
        else if (result.signal === 'WAIT') signalClass = 'bg-secondary';  // Gray for wait
        else if (result.signal === 'AVOID') signalClass = 'bg-danger';
        
        return `
            <tr>
                <td>${new Date(result.timestamp).toLocaleString()}</td>
                <td><strong>${result.symbol}</strong></td>
                <td class="text-center">
                    <span class="badge ${signalClass}">${result.signal}</span>
                </td>
                <td class="text-end">${result.confidence}</td>
                <td class="text-end">${(parseFloat(result.ml_probability) * 100).toFixed(1)}%</td>
                <td class="text-end">$${parseFloat(result.signal_price).toFixed(2)}</td>
                <td class="text-end">$${parseFloat(result.execution_price || 0).toFixed(2)}</td>
                <td class="text-end ${pnl >= 0 ? 'text-success' : 'text-danger'}">
                    $${parseFloat(result['pnl_$'] || 0).toFixed(2)}
                </td>
                <td class="text-end ${pnl >= 0 ? 'text-success' : 'text-danger'}">
                    ${pnl.toFixed(2)}%
                </td>
                <td class="text-center">
                    <span class="badge ${matched ? 'bg-success' : 'bg-secondary'}">
                        ${matched ? 'Yes' : 'No'}
                    </span>
                </td>
            </tr>
        `;
    }).join('');
}

function updateBestWorstTrades(results) {
    const matchedResults = results.filter(r => r.matched === true || r.matched === 'true' || r.matched === 'True');
    
    // Sort by P&L
    const sorted = [...matchedResults].sort((a, b) => 
        parseFloat(b['pnl_%'] || 0) - parseFloat(a['pnl_%'] || 0)
    );
    
    // Best trades
    const bestTrades = sorted.slice(0, 5);
    const bestHtml = bestTrades.map(trade => `
        <div class="d-flex justify-content-between align-items-center mb-2 p-2 bg-dark rounded">
            <div>
                <strong>${trade.symbol}</strong> - ${trade.signal}
                <br><small class="text-muted-xs">${new Date(trade.timestamp).toLocaleDateString()}</small>
            </div>
            <div class="text-success h5 mb-0">
                ${parseFloat(trade['pnl_%']).toFixed(2)}%
            </div>
        </div>
    `).join('');
    
    document.getElementById('bestTrades').innerHTML = bestHtml || '<div class="text-muted">No trades available</div>';
    
    // Worst trades (actually just lowest performing since all are positive)
    const worstTrades = sorted.slice(-5).reverse();
    const worstHtml = worstTrades.map(trade => `
        <div class="d-flex justify-content-between align-items-center mb-2 p-2 bg-dark rounded">
            <div>
                <strong>${trade.symbol}</strong> - ${trade.signal}
                <br><small class="text-muted-xs">${new Date(trade.timestamp).toLocaleDateString()}</small>
            </div>
            <div class="text-warning h5 mb-0">
                ${parseFloat(trade['pnl_%']).toFixed(2)}%
            </div>
        </div>
    `).join('');
    
    document.getElementById('worstTrades').innerHTML = worstHtml || '<div class="text-muted">No trades available</div>';
}

function updatePnLChart(results) {
    console.log('üîß updatePnLChart called with results:', results?.length || 0, 'items');
    
    const ctx = document.getElementById('pnlChart');
    if (!ctx) {
        console.error('‚ùå P&L Chart canvas element not found!');
        return;
    }
    
    console.log('‚úÖ Canvas element found:', ctx);
    
    // Check if Chart.js is loaded
    if (typeof Chart === 'undefined') {
        console.log('‚ö†Ô∏è Chart.js library not loaded - using HTML/CSS fallback chart');
        updatePnLChartFallback(results);
        return;
    }
    
    console.log('‚úÖ Chart.js library loaded');
    
    const matchedResults = results.filter(r => {
        const v = r?.matched;
        if (v === true || v === 1) return true;
        if (typeof v === 'string') {
            const s = v.trim().toLowerCase();
            return s === 'true' || s === '1' || s === 'yes' || s === 'y';
        }
        return false;
    });
    console.log('üìä Matched results:', matchedResults.length);
    
    const pnlValues = matchedResults.map(r => parseFloat(r['pnl_%'] || 0));
    const labels = matchedResults.map(r => new Date(r.timestamp).toLocaleDateString());
    
    console.log('üìä Chart data - Labels:', labels.length, 'Values:', pnlValues.length);
    
    // Destroy existing chart
    if (pnlChart) {
        console.log('üóëÔ∏è Destroying existing chart');
        pnlChart.destroy();
    }
    
    try {
        console.log('üé® Creating new chart...');
        pnlChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'P&L %',
                    data: pnlValues,
                    borderColor: '#28a745',
                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
        console.log('‚úÖ Chart created successfully:', pnlChart);
    } catch (error) {
        console.error('‚ùå Error creating chart:', error);
        updatePnLChartFallback(results);
    }
}

function updatePnLChartFallback(results) {
    console.log('üîß Creating HTML/CSS fallback P&L chart');
    
    const canvas = document.getElementById('pnlChart');
    const container = canvas.parentElement;
    
    // Hide the canvas and create HTML chart
    canvas.style.display = 'none';
    
    // Remove existing fallback chart if any
    const existingChart = container.querySelector('.fallback-chart');
    if (existingChart) {
        existingChart.remove();
    }
    
    if (!results || results.length === 0) {
        const noDataDiv = document.createElement('div');
        noDataDiv.className = 'fallback-chart text-center p-4';
        noDataDiv.innerHTML = `
            <div class="text-muted">
                <i class="fas fa-chart-line fa-3x mb-3"></i>
                <p>No backtest data available for chart display</p>
                <small>Run a backtest to see P&L distribution</small>
            </div>
        `;
        container.appendChild(noDataDiv);
        return;
    }
    
    // Filter matched results
    const matchedResults = results.filter(r => {
        const v = r?.matched;
        if (v === true || v === 1) return true;
        if (typeof v === 'string') {
            const s = v.trim().toLowerCase();
            return s === 'true' || s === '1' || s === 'yes' || s === 'y';
        }
        return false;
    });
    
    if (matchedResults.length === 0) {
        const noDataDiv = document.createElement('div');
        noDataDiv.className = 'fallback-chart text-center p-4';
        noDataDiv.innerHTML = `
            <div class="text-muted">
                <i class="fas fa-chart-line fa-3x mb-3"></i>
                <p>No matched results for chart display</p>
                <small>${results.length} total results, but none matched execution criteria</small>
            </div>
        `;
        container.appendChild(noDataDiv);
        return;
    }
    
    const pnlValues = matchedResults.map(r => parseFloat(r['pnl_%'] || 0));
    
    // Calculate statistics
    const avgPnL = pnlValues.reduce((a, b) => a + b, 0) / pnlValues.length;
    const minPnL = Math.min(...pnlValues);
    const maxPnL = Math.max(...pnlValues);
    const positiveCount = pnlValues.filter(p => p > 0).length;
    const negativeCount = pnlValues.filter(p => p < 0).length;
    const zeroCount = pnlValues.filter(p => p === 0).length;
    
    // Create histogram bins
    const binCount = Math.min(10, Math.max(5, Math.ceil(Math.sqrt(pnlValues.length))));
    const binSize = (maxPnL - minPnL) / binCount;
    const bins = Array(binCount).fill(0);
    
    pnlValues.forEach(value => {
        let binIndex = Math.floor((value - minPnL) / binSize);
        if (binIndex >= binCount) binIndex = binCount - 1;
        if (binIndex < 0) binIndex = 0;
        bins[binIndex]++;
    });
    
    const maxBinCount = Math.max(...bins);
    
    // Create the fallback chart
    const chartDiv = document.createElement('div');
    chartDiv.className = 'fallback-chart';
    chartDiv.innerHTML = `
        <style>
        .fallback-chart {
            width: 100%;
            height: 300px;
            background: var(--primary-dark);
            border-radius: 8px;
            padding: 20px;
            position: relative;
        }
        .chart-title {
            color: #e9ecef;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }
        .chart-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .stat-item {
            text-align: center;
            color: #adb5bd;
            font-size: 12px;
        }
        .stat-value {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
        }
        .stat-positive { color: var(--success-green); }
        .stat-negative { color: var(--danger-red); }
        .stat-neutral { color: var(--text-light); }
        .histogram {
            display: flex;
            align-items: end;
            height: 120px;
            gap: 2px;
            margin-top: 10px;
            padding: 0 10px;
        }
        .histogram-bar {
            flex: 1;
            background: linear-gradient(to top, var(--accent-blue), var(--success-green));
            border-radius: 2px 2px 0 0;
            min-height: 2px;
            position: relative;
            transition: all 0.3s ease;
        }
        .histogram-bar:hover {
            background: linear-gradient(to top, var(--success-green), var(--warning-orange));
            transform: scaleY(1.1);
        }
        .histogram-bar::after {
            content: attr(data-count);
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #adb5bd;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .histogram-bar:hover::after {
            opacity: 1;
        }
        </style>
        
        <div class="chart-title">P&L Distribution (${matchedResults.length} trades)</div>
        
        <div class="chart-stats">
            <div class="stat-item">
                <div class="stat-value stat-positive">+${positiveCount}</div>
                <div>Winners</div>
            </div>
            <div class="stat-item">
                <div class="stat-value stat-negative">-${negativeCount}</div>
                <div>Losers</div>
            </div>
            <div class="stat-item">
                <div class="stat-value stat-neutral">${zeroCount}</div>
                <div>Breakeven</div>
            </div>
            <div class="stat-item">
                <div class="stat-value stat-${avgPnL >= 0 ? 'positive' : 'negative'}">${avgPnL.toFixed(2)}%</div>
                <div>Avg P&L</div>
            </div>
            <div class="stat-item">
                <div class="stat-value stat-positive">${maxPnL.toFixed(2)}%</div>
                <div>Best</div>
            </div>
            <div class="stat-item">
                <div class="stat-value stat-negative">${minPnL.toFixed(2)}%</div>
                <div>Worst</div>
            </div>
        </div>
        
        <div class="histogram">
            ${bins.map((count, i) => {
                const height = maxBinCount > 0 ? (count / maxBinCount * 100) : 0;
                const binStart = minPnL + (i * binSize);
                const binEnd = binStart + binSize;
                return `<div class="histogram-bar" 
                           style="height: ${height}%" 
                           data-count="${count}"
                           title="${binStart.toFixed(1)}% to ${binEnd.toFixed(1)}%: ${count} trades"></div>`;
            }).join('')}
        </div>
    `;
    
    container.appendChild(chartDiv);
    console.log('‚úÖ Fallback P&L chart created successfully');
}

async function runNewBacktest() {
    try {
        console.log('üîÑ Starting new backtest...');
        
        // Show toast notification
        if (typeof showToast === 'function') {
            showToast('Starting new backtest...', 'info');
        } else {
            console.log('üì¢ Starting new backtest...');
        }
        
        // Run the Python backtest script
        const response = await fetch('/api/run-backtest', { method: 'POST' });
        console.log('üì° Backtest API response:', response.status);
        
        if (response.ok) {
            const result = await response.json();
            console.log('‚úÖ Backtest result:', result);
            
            if (typeof showToast === 'function') {
                showToast('Backtest completed successfully!', 'success');
            } else {
                console.log('üì¢ Backtest completed successfully!');
            }
            
            // Reload results
            setTimeout(() => {
                console.log('üîÑ Reloading backtest results...');
                loadBacktestResults();
            }, 2000);
        } else {
            throw new Error('Backtest execution failed');
        }
    } catch (error) {
        console.error('‚ùå Backtest error:', error);
        if (typeof showToast === 'function') {
            showToast('Error running backtest: ' + error.message, 'error');
        } else {
            console.error('üì¢ Error running backtest:', error.message);
        }
    }
}

async function exportBacktestResults() {
    try {
        showToast('Exporting backtest results...', 'info');
        
        const response = await fetch('/ml/backtest_results.csv');
        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'backtest_results.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showToast('Backtest results exported successfully!', 'success');
        } else {
            throw new Error('Export failed');
        }
    } catch (error) {
        showToast('Error exporting results: ' + error.message, 'error');
    }
}

async function refreshBacktestData() {
    await loadBacktestResults();
}

// Page-specific refresh function
window.refreshPageData = async function() {
    await loadBacktestResults();
};

// Initialize page
// üîß BACKTEST DEBUG FUNCTIONS
const BacktestDebug = {
    // Inspect backtest state
    inspectState() {
        TradingDebug.log('üß™ Backtest State Inspection');
        TradingDebug.inspectState('backtest data', window.backtestData);
        TradingDebug.inspectState('pnl chart', window.pnlChart);
        TradingDebug.inspectState('stats', window.backtestStats);
    },
    
    // Debug backtest loading
    async debugBacktest() {
        TradingDebug.log('üß™ Testing backtest loading...');
        try {
            await loadBacktestResults();
            TradingDebug.log('üß™ Backtest results loaded successfully');
            this.inspectState();
        } catch (error) {
            TradingDebug.trackError(error, 'Backtest Loading');
        }
    },
    
    // Test backtest APIs
    async testAPIs() {
        TradingDebug.log('üß™ Testing Backtest APIs...');
        const endpoints = [
            '/api/trades',
            '/api/performance-charts'
        ];
        
        for (const endpoint of endpoints) {
            await TradingDebug.helpers.testAPI(endpoint);
        }
    },
    
    // Force refresh backtest
    refreshBacktest() {
        TradingDebug.log('üß™ Forcing backtest refresh...');
        loadBacktestResults();
    },
    
    // Analyze backtest performance
    analyzePerformance() {
        if (!window.backtestData) {
            TradingDebug.log('No backtest data to analyze');
            return;
        }
        
        TradingDebug.log('üß™ Backtest Performance Analysis:');
        console.group('üß™ Performance Metrics');
        console.log('Total Signals:', window.backtestData.length);
        console.log('Win Rate:', window.backtestStats?.winRate);
        console.log('Total PnL:', window.backtestStats?.totalPnL);
        console.log('Best Trade:', window.backtestStats?.bestTrade);
        console.log('Worst Trade:', window.backtestStats?.worstTrade);
        console.groupEnd();
    }
};

// Load dynamic weights data
async function loadDynamicWeights() {
    try {
        console.log('üîÑ Loading dynamic weights...');
        
        const response = await fetch('/api/public/dynamic-weights');
        if (!response.ok) {
            throw new Error(`Failed to fetch dynamic weights: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
            console.log('‚úÖ Dynamic weights loaded:', data);
            
            // Update weights
            const mlWeight = Math.round(data.weights.ml_weight * 100);
            const taWeight = Math.round(data.weights.ta_weight * 100);
            
            document.getElementById('dynamicMLWeight').textContent = `${mlWeight}%`;
            document.getElementById('dynamicTAWeight').textContent = `${taWeight}%`;
            
            // Update correlations
            document.getElementById('mlCorrelationValue').textContent = 
                `Correlation: ${data.correlation.ml_correlation.toFixed(3)}`;
            document.getElementById('taCorrelationValue').textContent = 
                `Correlation: ${data.correlation.ta_correlation.toFixed(3)}`;
            
            // Update sample size
            document.getElementById('dynamicSampleSize').textContent = data.analysis.sample_size;
            
            // Update status
            const statusElement = document.getElementById('dynamicStatus');
            const statusDescElement = document.getElementById('dynamicStatusDesc');
            
            if (data.analysis.status === 'active') {
                statusElement.textContent = '‚úÖ ACTIVE';
                statusElement.className = 'h4 text-success';
                statusDescElement.textContent = 'System operational';
            } else if (data.analysis.status === 'insufficient_data') {
                statusElement.textContent = '‚ö†Ô∏è LEARNING';
                statusElement.className = 'h4 text-warning';
                statusDescElement.textContent = `Need ${50 - data.analysis.sample_size} more trades`;
            } else {
                statusElement.textContent = '‚ùå ERROR';
                statusElement.className = 'h4 text-danger';
                statusDescElement.textContent = 'System error';
            }
            
        } else {
            console.error('‚ùå Dynamic weights API error:', data.error);
            
            // Show fallback values
            document.getElementById('dynamicMLWeight').textContent = '40%';
            document.getElementById('dynamicTAWeight').textContent = '60%';
            document.getElementById('mlCorrelationValue').textContent = 'Error loading';
            document.getElementById('taCorrelationValue').textContent = 'Error loading';
            document.getElementById('dynamicSampleSize').textContent = 'N/A';
            document.getElementById('dynamicStatus').textContent = '‚ùå ERROR';
            document.getElementById('dynamicStatus').className = 'h4 text-danger';
            document.getElementById('dynamicStatusDesc').textContent = 'API error';
        }
        
    } catch (error) {
        console.error('‚ùå Dynamic weights loading failed:', error);
        
        // Show fallback UI
        document.getElementById('dynamicMLWeight').textContent = '40%';
        document.getElementById('dynamicTAWeight').textContent = '60%';
        document.getElementById('mlCorrelationValue').textContent = 'Connection error';
        document.getElementById('taCorrelationValue').textContent = 'Connection error';
        document.getElementById('dynamicSampleSize').textContent = 'N/A';
        document.getElementById('dynamicStatus').textContent = 'üîå OFFLINE';
        document.getElementById('dynamicStatus').className = 'h4 text-secondary';
        document.getElementById('dynamicStatusDesc').textContent = 'Connection failed';
    }
}

// Add backtest debug to global scope
window.backtestDebug = BacktestDebug;

document.addEventListener('DOMContentLoaded', function() {
    loadBacktestResults();
    loadDynamicWeights();
});
// Bootstrap the page when DOM loads
document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ DOM loaded, starting backtest results loading...');
    loadBacktestResults();
});

</script>
{% endblock %}
