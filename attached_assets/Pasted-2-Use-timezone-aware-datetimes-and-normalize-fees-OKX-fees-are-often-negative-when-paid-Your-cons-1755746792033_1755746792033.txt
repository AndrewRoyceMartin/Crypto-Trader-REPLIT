2) Use timezone-aware datetimes and normalize fees

OKX fees are often negative when paid. Your consumers typically want positive fee paid. Normalize to abs() and store the sign separately if needed.

Your datetime is naive; make it UTC.

âœ… Safer formatters
from datetime import datetime, timezone

def _format_okx_fill(self, fill: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    try:
        ts = int(fill.get('ts', 0)) or 0
        price = float(fill.get('fillPx', 0) or 0)
        qty = float(fill.get('fillSz', 0) or 0)
        fee_raw = float(fill.get('fee', 0) or 0)

        return {
            'id': fill.get('fillId', ''),
            'order_id': fill.get('ordId', ''),
            'client_order_id': fill.get('clOrdId', '') or None,
            'symbol': self._denormalize_symbol(fill.get('instId', '') or ''),
            'inst_type': fill.get('instType', '').upper() or self._inst_type(),
            'side': (fill.get('side', '') or '').upper(),
            'quantity': qty,
            'price': price,
            'timestamp': ts,
            'datetime': datetime.fromtimestamp(ts / 1000, tz=timezone.utc).isoformat() if ts else '',
            'total_value': qty * price,
            'fee': abs(fee_raw),
            'fee_sign': -1 if fee_raw < 0 else (1 if fee_raw > 0 else 0),
            'fee_currency': fill.get('feeCcy', ''),
            'trade_type': 'spot' if (fill.get('instType', '').upper() or self._inst_type()) == 'SPOT' else 'derivatives',
            'source': 'okx_fills',
        }
    except (ValueError, TypeError) as e:
        self.logger.debug(f"Failed to format OKX fill: {e}")
        return None

def _format_okx_order(self, order: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    try:
        if (order.get('state') or '').lower() != 'filled':
            return None

        # prefer accumulated filled size for filled orders
        qty = float(order.get('accFillSz') or order.get('fillSz') or order.get('sz') or 0)
        price = float(order.get('avgPx') or order.get('px') or 0)
        ts = int(order.get('uTime') or order.get('cTime') or 0)
        fee_raw = float(order.get('fee', 0) or 0)

        return {
            'id': order.get('ordId', ''),
            'order_id': order.get('ordId', ''),
            'client_order_id': order.get('clOrdId', '') or None,
            'symbol': self._denormalize_symbol(order.get('instId', '') or ''),
            'inst_type': order.get('instType', '').upper() or self._inst_type(),
            'side': (order.get('side', '') or '').upper(),
            'quantity': qty,
            'price': price,
            'timestamp': ts,
            'datetime': datetime.fromtimestamp(ts / 1000, tz=timezone.utc).isoformat() if ts else '',
            'total_value': qty * price if (qty and price) else float(order.get('notionalUsd', 0) or 0),
            'fee': abs(fee_raw),
            'fee_sign': -1 if fee_raw < 0 else (1 if fee_raw > 0 else 0),
            'fee_currency': order.get('feeCcy', ''),
            'trade_type': 'spot' if (order.get('instType', '').upper() or self._inst_type()) == 'SPOT' else 'derivatives',
            'source': 'okx_orders',
        }
    except (ValueError, TypeError) as e:
        self.logger.debug(f"Failed to format OKX order: {e}")
        return None