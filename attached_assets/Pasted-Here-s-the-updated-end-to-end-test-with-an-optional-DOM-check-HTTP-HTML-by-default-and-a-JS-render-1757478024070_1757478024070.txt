Here’s the updated end-to-end test with an optional DOM check (HTTP/HTML by default, and a JS-rendered check via Playwright when enabled).

Plan

Keep all previous checks (env, OKX public/private, candles, ML, hybrid, logs).

Add check_dom_http() (fast, no JS) using requests + BeautifulSoup.

Add check_dom_js() (optional, headless Playwright) for SPA/JS-rendered UIs.

Configure via env:

APP_URL (required for DOM checks)

DOM_SELECTORS (JSON list of CSS selectors; defaults provided)

DOM_CHECK_JS=true to enable JS-rendered check.

requirements.txt additions
beautifulsoup4
playwright ; extra == "js"  # Optional (set if you want JS checks)


If using JS checks, run once in Replit Shell: python -m playwright install --with-deps

tests/e2e_system_check.py
# tests/e2e_system_check.py
"""
End-to-end system check for OKX connectivity, real data retrieval, ML model, hybrid signal,
and optional DOM/UI checks (HTTP-only and Playwright JS mode).
Run: python -m tests.e2e_system_check
"""

import os
import sys
import time
import json
import base64
import hmac
import hashlib
from datetime import datetime, timezone
from typing import Dict, List, Tuple

import requests
import pandas as pd
import numpy as np
from bs4 import BeautifulSoup  # HTTP DOM parsing (no JS)

# -------- Configuration --------
OKX_BASE = "https://www.okx.com"
TIMEOUT = 10
TEST_SYMBOLS = ["BTC-USDT", "ETH-USDT", "SOL-USDT"]
MODEL_PATH = "buy_regression_model.pkl"
SIGNALS_LOG = "signals_log.csv"
BACKTEST_FILE = "backtest_results.csv"

# DOM config via env
APP_URL = os.getenv("APP_URL", "").strip()
DOM_SELECTORS_ENV = os.getenv("DOM_SELECTORS", "")
try:
    DOM_SELECTORS = json.loads(DOM_SELECTORS_ENV) if DOM_SELECTORS_ENV else [
        "#app, .app, body",                    # generic container
        "[data-testid='hybrid-score']",        # your UI can expose these ids
        "[data-testid='last-signal']",
        "[data-testid='status-okx']"
    ]
except Exception:
    DOM_SELECTORS = ["body"]
DOM_CHECK_JS = os.getenv("DOM_CHECK_JS", "false").lower() in {"1","true","yes"}

# -------- Console helpers --------
def okx_ts_utc() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="milliseconds").replace("+00:00", "Z")

def assert_true(cond: bool, msg: str):
    if not cond:
        raise AssertionError(msg)

def green(s: str) -> str:
    return f"\033[92m{s}\033[0m"

def yellow(s: str) -> str:
    return f"\033[93m{s}\033[0m"

def red(s: str) -> str:
    return f"\033[91m{s}\033[0m"

# -------- OKX auth helpers --------
def okx_headers(method: str, path: str, body: str = "") -> Dict[str, str]:
    ts = okx_ts_utc()
    secret = os.getenv("OKX_SECRET_KEY", "")
    msg = f"{ts}{method}{path}{body}"
    sig = base64.b64encode(hmac.new(secret.encode(), msg.encode(), hashlib.sha256).digest()).decode()
    return {
        "OK-ACCESS-KEY": os.getenv("OKX_API_KEY", ""),
        "OK-ACCESS-SIGN": sig,
        "OK-ACCESS-TIMESTAMP": ts,
        "OK-ACCESS-PASSPHRASE": os.getenv("OKX_PASSPHRASE", ""),
        "Content-Type": "application/json",
    }

# -------- Core checks --------
def check_env() -> None:
    print("1) Checking env secrets...")
    for key in ["OKX_API_KEY", "OKX_SECRET_KEY", "OKX_PASSPHRASE"]:
        val = os.getenv(key, "")
        assert_true(bool(val), f"Missing env secret: {key}")
    print(green("   ✓ Secrets present"))

def check_okx_public() -> Dict:
    print("2) Checking OKX public API (live market/tickers)...")
    url = f"{OKX_BASE}/api/v5/market/tickers"
    r = requests.get(url, params={"instType": "SPOT"}, timeout=TIMEOUT)
    assert_true(r.status_code == 200, f"Public API status {r.status_code}")
    data = r.json()
    assert_true(data.get("code") == "0", f"Public API error: {data}")
    tickers = data.get("data", [])
    assert_true(len(tickers) > 0, "No tickers returned")
    srv_date = r.headers.get("Date")
    assert_true(srv_date is not None, "Missing server Date header")
    inst_ids = {t.get("instId") for t in tickers}
    assert_true(any(s in inst_ids for s in TEST_SYMBOLS), "Expected test symbols not in public tickers")
    print(green("   ✓ Public API OK (live)"))
    return data

def fetch_candles(inst_id: str, bar="1H", limit=50) -> pd.DataFrame:
    url = f"{OKX_BASE}/api/v5/market/candles"
    r = requests.get(url, params={"instId": inst_id, "bar": bar, "limit": limit}, timeout=TIMEOUT)
    assert_true(r.status_code == 200, f"Candles API status {r.status_code}")
    payload = r.json()
    assert_true(payload.get("code") == "0", f"Candles API error: {payload}")
    rows = payload.get("data", [])
    assert_true(len(rows) >= 10, f"Too few candles for {inst_id}")
    recs = []
    for c in rows:
        recs.append({
            "ts": int(c[0]), "open": float(c[1]), "high": float(c[2]),
            "low": float(c[3]), "close": float(c[4]), "vol": float(c[5]),
        })
    df = pd.DataFrame(recs)
    df["price"] = df["close"]
    df["date"] = pd.to_datetime(df["ts"], unit="ms", utc=True)
    return df.sort_values("date")

def check_candles_real() -> Dict[str, pd.DataFrame]:
    print("3) Fetching real candles for test symbols...")
    out = {}
    for sym in TEST_SYMBOLS:
        df = fetch_candles(sym, bar="1H", limit=50)
        assert_true(df["price"].nunique() > 1, f"Constant prices detected for {sym}")
        assert_true(df["vol"].sum() > 0, f"Zero volume series for {sym}")
        last_dt = df["date"].iloc[-1]
        age_min = (datetime.now(timezone.utc) - last_dt).total_seconds() / 60.0
        assert_true(age_min <= 120, f"Stale candles for {sym}, age(min)={age_min:.1f}")
        out[sym] = df
    print(green("   ✓ Real candles OK"))
    return out

def check_okx_private_fills() -> pd.DataFrame:
    print("4) Checking OKX private API (trade fills)...")
    path = "/api/v5/trade/fills"
    url = f"{OKX_BASE}{path}"
    headers = okx_headers("GET", path, "")
    r = requests.get(url, headers=headers, params={"instType": "SPOT", "limit": 10}, timeout=TIMEOUT)
    assert_true(r.status_code == 200, f"Private API status {r.status_code}")
    data = r.json()
    assert_true(data.get("code") == "0", f"Private API auth error: {data}")
    print(green("   ✓ Private API OK (authenticated)"))
    return pd.DataFrame(data.get("data", []))

def load_model() -> Tuple[object, List[str]]:
    print("5) Loading regression model...")
    import joblib
    assert_true(os.path.isfile(MODEL_PATH), f"Missing model file: {MODEL_PATH}")
    model = joblib.load(MODEL_PATH)
    print(green("   ✓ Model loaded"))
    return model, ["confidence_score", "ml_probability"]

def run_model_inference(model, candles: Dict[str, pd.DataFrame]) -> Dict:
    print("6) Running hybrid score with real features...")
    def simple_indicators(df: pd.DataFrame) -> Dict[str, float]:
        prices = df["price"].values
        deltas = np.diff(prices)
        gains = np.maximum(deltas, 0)
        losses = np.maximum(-deltas, 0)
        avg_gain = gains[-14:].mean() if len(gains) >= 14 else (gains.mean() if len(gains) else 0)
        avg_loss = losses[-14:].mean() if len(losses) >= 14 else (losses.mean() if len(losses) else 1e-6)
        rs = avg_gain / (avg_loss if avg_loss > 0 else 1e-6)
        rsi = 100 - (100 / (1 + rs))
        mom = (prices[-1] - prices[-5]) / prices[-5] * 100 if len(prices) >= 6 else 0
        return {"rsi": float(rsi), "momentum_5": float(mom)}

    df_btc = candles[TEST_SYMBOLS[0]]
    ind = simple_indicators(df_btc)

    confidence_score = 50.0
    if ind["rsi"] < 35: confidence_score += 10
    if ind["momentum_5"] > 0: confidence_score += 10

    ml_probability = min(max(ind["momentum_5"] / 10.0, 0.0), 1.0)
    X = np.array([[confidence_score, ml_probability]], dtype=float)
    pred_return = float(model.predict(X)[0])

    hybrid_score = 0.6 * confidence_score + 0.4 * (ml_probability * 100.0)

    if hybrid_score >= 75:
        final_signal = "BUY"
    elif hybrid_score >= 60:
        final_signal = "CONSIDER"
    elif hybrid_score >= 45:
        final_signal = "WAIT"
    else:
        final_signal = "AVOID"

    result = {
        "symbol": TEST_SYMBOLS[0],
        "confidence_score": round(confidence_score, 2),
        "ml_probability": round(ml_probability, 4),
        "predicted_return_pct": round(pred_return, 4),
        "hybrid_score": round(hybrid_score, 2),
        "final_signal": final_signal,
        "rsi": round(ind["rsi"], 2),
        "momentum_5": round(ind["momentum_5"], 3),
    }
    print(green("   ✓ Hybrid inference succeeded"))
    return result

def append_signal_log(entry: Dict) -> None:
    print("7) Appending to signals_log.csv ...")
    row = {
        "timestamp": datetime.utcnow().isoformat(),
        "symbol": entry["symbol"],
        "current_price": None,
        "confidence_score": entry["confidence_score"],
        "timing_signal": entry["final_signal"],
        "rsi": entry["rsi"],
        "volatility": None,
        "volume_ratio": None,
        "momentum_signal": entry["momentum_5"] > 0,
        "support_signal": None,
        "bollinger_signal": None,
        "ml_probability": entry["ml_probability"],
        "hybrid_score": entry["hybrid_score"],
        "predicted_return_pct": entry["predicted_return_pct"],
    }
    df = pd.DataFrame([row])
    if os.path.isfile(SIGNALS_LOG):
        df.to_csv(SIGNALS_LOG, mode="a", header=False, index=False)
    else:
        df.to_csv(SIGNALS_LOG, index=False)
    print(green("   ✓ Signal logged"))

def check_backtest_file_if_present() -> None:
    print("8) Checking backtest_results.csv (optional)...")
    if not os.path.isfile(BACKTEST_FILE):
        print(yellow("   • backtest_results.csv not found (skipping)"))
        return
    df = pd.read_csv(BACKTEST_FILE)
    req_cols = {"timestamp", "symbol", "signal", "confidence", "ml_probability"}
    assert_true(req_cols.issubset(df.columns), "backtest_results.csv missing required columns")
    print(green("   ✓ Backtest file schema OK"))

# -------- DOM checks --------
def check_dom_http() -> None:
    if not APP_URL:
        print(yellow("9) APP_URL not set; skipping DOM checks"))
        return
    print("9) DOM check (HTTP/HTML)...")
    r = requests.get(APP_URL, timeout=TIMEOUT)
    assert_true(r.status_code == 200, f"App URL status {r.status_code}")
    html = r.text
    soup = BeautifulSoup(html, "html.parser")
    for sel in DOM_SELECTORS:
        found = soup.select_one(sel)
        assert_true(found is not None, f"Selector not found (HTTP): {sel}")
    print(green("   ✓ DOM (HTTP) selectors present"))

def check_dom_js() -> None:
    if not (APP_URL and DOM_CHECK_JS):
        if APP_URL:
            print(yellow("   • DOM_CHECK_JS not enabled; skipping JS-rendered check"))
        return
    print("   JS-rendered DOM check (Playwright)...")
    try:
        from playwright.sync_api import sync_playwright
    except Exception as e:
        raise AssertionError(
            "Playwright not installed. Run: `python -m playwright install --with-deps`"
        ) from e

    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        ctx = browser.new_context()
        page = ctx.new_page()
        page.goto(APP_URL, wait_until="load", timeout=30000)
        # wait a moment for SPA to render
        page.wait_for_timeout(1500)
        for sel in DOM_SELECTORS:
            el = page.query_selector(sel)
            assert_true(el is not None, f"Selector not found (JS): {sel}")
            # optional: ensure element is visible
            box = el.bounding_box()
            assert_true(box is not None, f"Selector not visible (JS): {sel}")
        browser.close()
    print(green("   ✓ DOM (JS) selectors present"))

# -------- Main --------
def main():
    try:
        check_env()
        check_okx_public()
        candles = check_candles_real()
        _fills = check_okx_private_fills()
        model, _ = load_model()
        result = run_model_inference(model, candles)
        append_signal_log(result)
        check_backtest_file_if_present()
        check_dom_http()
        check_dom_js()

        print("\n" + green("ALL CHECKS PASSED"))
        print(json.dumps(result, indent=2))
        sys.exit(0)
    except Exception as e:
        print("\n" + red("CHECK FAILED"))
        print(red(str(e)))
        sys.exit(1)

if __name__ == "__main__":
    main()

How to run
pip install -r requirements.txt
# (Only if JS DOM check enabled)
python -m playwright install --with-deps

# Run tests
python -m tests.e2e_system_check

Env setup for DOM
APP_URL=https://<your-replit-app-url>
DOM_SELECTORS=["#app",".some-class","[data-testid='hybrid-score']"]
DOM_CHECK_JS=true   # optional: enable Playwright JS check


This guarantees:

Live OKX data (no simulation)

Authenticated private access

Real candles, non-constant & fresh

Model loads and infers

Hybrid scoring/logging works

DOM present (HTTP-only) and JS-rendered DOM (optional)